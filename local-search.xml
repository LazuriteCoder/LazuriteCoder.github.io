<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>人工智能 机器学习与深度学习</title>
    <link href="/2022/05/05/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/05/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>机器学习：让机器（计算机）从数据中学习知识（即自动获取知识）。</p><p>深度学习：深度学习是机器学习的子领域，其主要出发点是模拟人脑神经系统的深层结构和人脑认知过程的逐层抽象、逐次迭代机制。</p><h2 id="main">Main</h2><h3 id="机器学习">机器学习</h3><h4 id="概述">概述</h4><h5 id="总述">总述</h5><p>机器学习的概念： 机器学习就是让机器（计算机）来模拟和实现人类的学习功能。（一般性解释） 简单来讲，就是让机器（计算机）从数据中学习知识（即自动获取知识）。</p><p>机器学习发展历史： <img src="/imgs/AI/机器学习与深度学习/机器学习发展历史.png" alt="机器学习发展史" /></p><p>机器学习分类： - 按学习策略分：记忆学习、传授学习、演绎学习、归纳学习等。归纳学习又可分为示例学习、观察发现学习等。 - 按学习方式分：有导师学习（监督学习）、无导师学习（非监督学习）和强化学习（增强学习）</p><h5 id="监督学习">监督学习:</h5><p>监督学习的三要素 - 标注数据：标识了类别信息的数据 - 从训练数据集学习得到映射函数 - 在测试数据集测试映射函数 - 在未知数据集实践映射函数 - 学习模型：如何学习得到映射模型 - 生成式法——生成（式）模型 - 生成模型从数据中学习联合概率分布 <span class="math inline">\(P(X, Y)\)</span>（通过似然概率 <span class="math inline">\(P(X|Y)\)</span> 和类概率 <span class="math inline">\(P(Y)\)</span> 的乘积来求取） - 典型方法为贝叶斯方法、隐马尔可夫链 - 授之于鱼不如授之于“渔” - 联合分布概率 <span class="math inline">\(P(X, Y)\)</span> 或似然概率 <span class="math inline">\(P(X|Y)\)</span> 求取很困难 - 判别式法——判别（式）模型 - 判别方法直接学习判别函数 <span class="math inline">\(f(x)\)</span> 或者条件概率分布 <span class="math inline">\(P(Y|X)\)</span> 作为预测的模型，即判别模型。 - 典型判别模型包括回归模型、决策模型、神经网络、支持向量机和集成模型等 - 判别模型关心在给定输入数据下，预测该数据的输出是什么。 - 损失函数：如何对学习结果进行度量 - 损失函数就是用来计算 <span class="math inline">\(x_i\)</span> 真实值 <span class="math inline">\(y_i\)</span> 与预测值 <span class="math inline">\(f(x_i)\)</span> 之间差值的函数 - 经验风险和期望风险： - 期望风险是模型关于联合分布期望损失，经验风险是模型关于训练样本集平均损失。 - 根据大数定律，当样本容量趋于无穷时，经验风险趋于期望风险。所以在实践中很自然用经验风险来估计期望风险。 - 由于现实中训练样本数目有限，用经验风险估计期望风险并不理想，要对经验风险进行一定的约束。 - 结构风险： - 经验风险最小化：仅反映了局部数据 - 期望风险最小化：无法得到全量数据 - 结构风险最小化：为了防止过拟合，在经验风险上加上表示模型复杂度的正则化项或惩罚项</p><figure><img src="/imgs/AI/机器学习与深度学习/经典损失函数.png" alt="经典损失函数" /><figcaption>经典损失函数</figcaption></figure><table><thead><tr class="header"><th>经验风险</br>（训练集表现）</th><th>期望风险</br>（测试集表现）</th><th>评价</th></tr></thead><tbody><tr class="odd"><td>小</td><td>小</td><td>泛化能力强</td></tr><tr class="even"><td>小</td><td>大</td><td>过学习（过拟合？）</td></tr><tr class="odd"><td>大</td><td>大</td><td>欠学习</td></tr><tr class="even"><td>大</td><td>小</td><td>“神仙算法”、“黄粱一梦” </br> （你觉得存在吗？）</td></tr></tbody></table><figure><img src="/imgs/AI/机器学习与深度学习/结构风险最小化.png" alt="结构风险最小化" /><figcaption>结构风险最小化</figcaption></figure><h4 id="线性回归">线性回归</h4><p>Q: 什么是回归分析？ A: 分析不同变量之间存在关系的研究叫回归分析，刻画不同变量之间关系的模型被称为回归模型。</p><p>Q: 什么是线性回归？ A: 如果这个模型是线性的，则称为线性回归模型</p><p>至于回归的过程什么的，直接上例子最直接了！ <img src="/imgs/AI/机器学习与深度学习/线性回归例-1.png" alt="线性回归例-1" /> 构建关系 <img src="/imgs/AI/机器学习与深度学习/线性回归例-2.png" alt="线性回归例-2" /> 回归模型是最小化残差平方和的均值 <img src="/imgs/AI/机器学习与深度学习/线性回归例-3.png" alt="线性回归例-3" /></p><figure><img src="/imgs/AI/机器学习与深度学习/线性回归例-4.png" alt="线性回归例-4" /><figcaption>线性回归例-4</figcaption></figure><figure><img src="/imgs/AI/机器学习与深度学习/线性回归例-5.png" alt="线性回归例-5" /><figcaption>线性回归例-5</figcaption></figure><h4 id="决策树学习">决策树学习</h4><p>Q: 什么是决策树？ A: 一种由节点和边构成的用来描述分类过程的层次数据结构.</p><p>Q: 决策树的结构？ A: - <strong>根节点</strong>：表示分类的开始 - <strong>叶节点</strong>：表示一个实例的结束 - <strong>中间节点</strong>：表示相应实例中的某一属性 - <strong>边代表</strong>：某一属性可能的属性值 - <strong>路径</strong>：从根节点到叶节点的每一条路径都代表一个具体的实例，并且<strong>同一路径</strong>上的所有属性之间为<strong>合取</strong>关系，<strong>不同路径</strong>（即一个属性的不同属性值）之间为<strong>析取</strong>关系。 - <strong>决策树的分类过程</strong>：从树的根接点开始，按照给定的事例的属性值去测试对应的树枝，并依次下移，直至到达某个叶节点为止。</p><p>一个决策树的例子如下： <img src="/imgs/AI/机器学习与深度学习/决策树例.png" alt="决策树例" /></p><p>常用算法：ID3、C4.5、C5.0 和随机森林 ID3：计算信息熵 步骤： 基础思路 <img src="/imgs/AI/机器学习与深度学习/ID3-1.png" alt="ID3-1" /> 信息熵与信息增益 <img src="/imgs/AI/机器学习与深度学习/ID3-2.png" alt="ID3-2" /></p><p>直接看例子： <img src="/imgs/AI/机器学习与深度学习/ID3例-1.png" alt="ID3例-1" /> <img src="/imgs/AI/机器学习与深度学习/ID3例-2.png" alt="ID3例-2" /> <img src="/imgs/AI/机器学习与深度学习/ID3例-3.png" alt="ID3例-3" /> <img src="/imgs/AI/机器学习与深度学习/ID3例-4.png" alt="ID3例-4" /> <img src="/imgs/AI/机器学习与深度学习/ID3例-5.png" alt="ID3例-5" /> <img src="/imgs/AI/机器学习与深度学习/ID3例-6.png" alt="ID3例-6" /></p><h4 id="支持向量机">支持向量机</h4><h5 id="总述-1">总述</h5><p>SVM 的基本信息： - 以 VC 维理论为基础 - 利用最大间隔算法去近似地实现结构风险最小化原理 - 基于统计学习理论 - 不仅可以很好地解决线性可分问题，而且可以利用核函数有效地解决线性不可分问题</p><ol type="1"><li>线性可分与最优分类超平面 线性可分问题分类是 SVM 学习方法的基础，SVM 是通过最优分类超平面来实现其分类的。</li><li>非线性可分与核函数 对非线性可分问题，SVM 采用特征空间映射方式，即将非线性可分的样本集映射到高维空间，使其在高维空间中被转变为线性可分。即采用核函数的方法。</li></ol><h5 id="线性可分与最优分类超平面">线性可分与最优分类超平面</h5><p><img src="/imgs/AI/机器学习与深度学习/线性可分与最优线性超平面-概念.png" alt="线性可分与最优分类超平面" /> <img src="/imgs/AI/机器学习与深度学习/线性可分与最优线性超平面-分类间隔.png" alt="线性可分与最优分类超平面" /> <img src="/imgs/AI/机器学习与深度学习/线性可分与最优线性超平面-求解.png" alt="线性可分与最优分类超平面" /></p><h5 id="非线性可分与核函数">非线性可分与核函数</h5><figure><img src="/imgs/AI/机器学习与深度学习/非线性可分与核函数.png" alt="非线性可分与核函数" /><figcaption>非线性可分与核函数</figcaption></figure><h4 id="集成学习">集成学习</h4><p>Q: 什么是集成学习？ A: 集成学习是指为解决同一问题，先训练出<strong>一系列</strong>个体学习器（或称弱学习器），然后再根据某种规则把这些个体学习器的学习结果整合到一起，得到比单个个体学习器更好的学习效果。</p><p>Q: 集成学习的基本问题？ A: 1. 个体学习器的构造； 2. 个体学习器合成</p><p>Q: 集成学习器的方式？ A: - 同质集成（狭义集成学习）：构造个体学习器时使用相同类型的学习方法，个体学习器称为基学习器，所用的学习算法称为基学习算法。 - 异质集成（广义集成学习）：构造个体学习器时可以使用不同类型的学习方法</p><h3 id="深度学习">深度学习</h3><h4 id="概述-1">概述</h4><ul><li>深度学习是机器学习的子领域，其主要出发点是模拟人脑神经系统的深层结构和人脑认知过程的逐层抽象、逐次迭代机制。</li><li>深度学习基于深层网络模型、面向低层数据对象、采用逐层抽象机制、逐层学习、最终形成高层概念的机器学习方式。</li><li>目前，深度学习的研究和应用领域十分广泛，尤其是对视频、音频、语言数据的处理，更是独具优势。</li></ul><p>神经元： - 对输入信息进行加权累加：<span class="math inline">\(In = \sum^n_{i=1} w_i * a_i\)</span> - 对累加结果进行非线性变换（通过激活函数）:<span class="math inline">\(g(x)\)</span> - 神经元的输出：<span class="math inline">\(Out=g(In+b)\)</span></p><p>激活函数： <img src="/imgs/AI/机器学习与深度学习/常用激活函数.png" alt="常用激活函数" /></p><h4 id="前馈神经网络">前馈神经网络</h4><ol type="1"><li>基本形式： 输入层 — 隐藏层 — 输出层</li></ol><ul><li>各个神经元接受前一级的输入，并输出到下一级，模型中没有反馈</li><li>层与层之间通过“全连接”进行链接，即两个相邻层之间的神经元完全成对连接，但层内的神经元不相互连接</li></ul><ol start="2" type="1"><li>参数优化： 梯度下降：</li></ol><p>反向传播：</p><h4 id="几种常见的神经网络">几种常见的神经网络</h4><h5 id="卷积神经网络-cnn">卷积神经网络 CNN</h5><p>基本操作： 1. 卷积 2. 池化 3. 分类</p><h5 id="循环神经网络-rnn">循环神经网络 RNN</h5><p>几个变种： 1. 长短期记忆 (Long Short-Term Memory, LSTM)</p><ol start="2" type="1"><li>门控循环单元 (Gated Recurrent Unit, GRU)</li></ol><h5 id="transformer">Transformer</h5><figure><img src="/imgs/AI/机器学习与深度学习/Transformer.png" alt="Transformer" /><figcaption>Transformer</figcaption></figure><h2 id="conclusion">Conclusion</h2><p>好多内容都是概念方面的，注重理解罢！ （很多就是贴了图，总之简单注意吧！）</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能 搜索</title>
    <link href="/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>首先介绍一下知识结构： <img src="/imgs/AI/搜索/搜索知识结构.png" alt="搜索知识结构" /> 都是老熟人了。</p><p>概念： 依靠经验，利用已有知识，根据问题的实际情况，不断寻找可利用知识，从而构造一条代价最小的推理路线，使问题得以解决的过程称为搜索 适用情况： 不良结构或非结构化问题；难以获得求解所需的全部信息；更没有现成的算法可供求解使用。结构良好，理论上有算法可以的，但问题或算法的复杂性较高 搜索的分类 按是否使用启发式信息： 盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。 启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。 按问题的表示方式： 状态空间搜索：用状态空间法来求解问题所进行的搜索 与或树搜索：用问题归约法来求解问题时所进行的搜索</p><h2 id="main">Main</h2><h3 id="状态空间盲目搜索">状态空间盲目搜索</h3><p>常用方法： BFS、DFS、UCS 方法都很熟悉了，这里介绍一下结果： BFS： - 最优解 - 效率低 - 完备</p><p>DFS： - 一般不是最优解 - 最坏情况相当于穷举</p><p>UCS： - BFS 的一种推广 - 优先扩展代价低节点</p><h3 id="状态空间启发式搜索">状态空间启发式搜索</h3><p>核心： <span class="math inline">\(f(n) = g(n) + h(n)\)</span> 启发函数、实际代价、估计代价 启发信息的启发能力越强，扩展的无用结点越少，搜索算法越高效。启发信息包括以下3种： - 有效地帮助确定扩展节点的信息； - 有效地帮助决定哪些后继节点应被生成的信息； - 能决定在扩展一个节点时哪些节点应从搜索树上删除的信息。</p><p>那么有什么算法是启发式搜索呢？ 贪心算法、A 算法和 A* 算法。</p><p>贪心： - 局部最优解 - Greedy orders by goal proximity, or forward cost h(n).</p><p>A 搜索： - 代价一致 + 贪心 - <strong>Uniform-cost</strong> orders by path cost, or backward cost g(n). - <strong>Greedy</strong> orders by goal proximity, or forward cost h(n). 大概是怎么样呢？举个例子： <img src="/imgs/AI/搜索/A算法举个例子.png" alt="举个例子" /></p><p>那么来解决一个实际问题——八数码 <img src="/imgs/AI/搜索/八数码题干.png" alt="题干" /> <img src="/imgs/AI/搜索/八数码题解.png" alt="题解" /></p><p>A* - 缩小总评代价 - 对<strong>估价函数加上某些限制</strong>后得到的启发式算法</p><p>假设 <span class="math inline">\(f^*(n)\)</span> 是从初始节点 <span class="math inline">\(S_0\)</span> 出发，约束经过节点 n 到达目标节点 <span class="math inline">\(S_g\)</span> 的最小代价，估价函数 <span class="math inline">\(f(n)\)</span> 是对 <span class="math inline">\(f^*(n)\)</span>的估计值。记 <span class="math inline">\(f^*(n) = g^*(n) + h^*(n)\)</span> 其中，<span class="math inline">\(g^*(n)\)</span> 是从 <span class="math inline">\(S_0\)</span> 出发到达 n 的最小代价，<span class="math inline">\(h^*(n)\)</span> 是 n 到 <span class="math inline">\(S_g\)</span> 的最小代价。</p><p>那么，如果对于 A 算法，做出如下限制： 1. <span class="math inline">\(g(n)\)</span> 是 <span class="math inline">\(g^*(n)\)</span> 的估计，且 <span class="math inline">\(g(n) &gt; 0\)</span> 2. <span class="math inline">\(h(n)\)</span> 是 <span class="math inline">\(h^*(n)\)</span> 的下界，对任一节点 n 都有：<span class="math inline">\(h(n) &lt; h^*(n)\)</span> 它就可以成为 A* 算法。 <img src="/imgs/AI/搜索/Astar的例子.png" alt="A*例" /></p><p>A* 算法解决八数码问题： <img src="/imgs/AI/搜索/Astar八数码.png" alt="题干" /> <img src="/imgs/AI/搜索/Astar八数码解.png" alt="题解" /></p><p>关于 A* 算法，还有一个 <span class="math inline">\(h(n)\)</span> 的单调限制有关问题： 主要是两个条件： 1. <span class="math inline">\(h(S_g) = 0\)</span> 2. 对任一节点 <span class="math inline">\(n_i\)</span> 及其子节点 <span class="math inline">\(n_j\)</span> 有： <span class="math inline">\(0 \le h(n_i) - h(n_j) \le c(n_i,n_j)\)</span> <span class="math inline">\(c(n_i,n_j)\)</span>是 <span class="math inline">\(n_i\)</span> 到其子节点 <span class="math inline">\(n_j\)</span> 的边代价。</p><p>满足单调性限制下的 A* 算法常被称为改进的 A* 算法。</p><h3 id="与或树搜索">与/或树搜索</h3><p>盲目搜索的部分应该差不多，这里描述启发式搜索的内容： #### 解树的代价和希望树 要求解最优解树，需要获得解树的代价，计算方法如下： 1. 若 n 为终止节点，则代价：<span class="math inline">\(h(n) = 0\)</span> 2. 若 n 为或节点，代价为 <span class="math inline">\(h(n) = min\{ c(n, n_i) + h(n_i) \}\)</span> - 即为：（子节点代价 + 该或节点到子节点的边代价）的最小值 3. 若 n 为与节点，计算代价有两种方式： - 和代价法：$h(n) = ^k_i [c(n, n_i) + h(n_i)] $ - 最大代价法：$h(n) = max{c(n, n_i) + h(n+i) } $ 4. 若 n 是端节点但不是终止节点，代价：<span class="math inline">\(h(n) = \infty\)</span> 5. 根节点的代价即为解树的代价</p><p>希望树： 为找到最佳解树，搜索过程的任何时刻都应该选择有希望成为最佳解树一部分的节点进行扩展；</p><p>这些节点及其父节点所构成的与或树<strong>最有可能成为最佳解树的一部分</strong>，因此称之为<strong>希望树</strong>。</p><p>启发式搜索过程就是不断选择修正希望树的过程。</p><p>对于希望树，有： 1. 初始节点 <span class="math inline">\(S_0\)</span> 在希望树中 2. 如果节点是或节点，那么（子节点代价 + 该或节点到子节点的边代价）的最小值的的子节点在希望树中 3. 如果节点是与节点，那么子节点都在希望树中</p><h4 id="与或树的启发式搜索过程">与/或树的启发式搜索过程</h4><p>总之放个例子： （应该是默认路径代价为 1） <img src="/imgs/AI/搜索/与或树启发式搜索1.png" alt="与或树启发式搜索1" /> 首先算一下左右子树的代价</p><p><img src="/imgs/AI/搜索/与或树启发式搜索2.png" alt="与或树启发式搜索2" /> 对希望树进行扩展</p><p><img src="/imgs/AI/搜索/与或树启发式搜索3.png" alt="与或树启发式搜索3" /> 继续扩展，这一步只是恰好碰到了终止节点，标记可解 （标记可解的过程注意结合与或树的性质进行）</p><p><img src="/imgs/AI/搜索/与或树启发式搜索4.png" alt="与或树启发式搜索4" /> 继续扩展，继续标记</p><h3 id="博弈树的启发式搜索">博弈树的启发式搜索</h3><h4 id="博弈树概述">博弈树概述</h4><p>实际上是一个把博弈过程建模成树的过程（？） 假设一方为 MAX，另一方为 MIN：</p><p>从 MAX 一方的观点来考虑：</p><p>对于 MAX：方案为“或”的关系 - 选择怎样的方案由自己决定。</p><p>对于 MIN：方案为“与”的关系 - 对方（对于 MAX 方而言）的任何方案都能被选中。</p><p>所以博弈树可以建模成这样的情况： 1. 博弈的初始状态是初始节点 2. 博弈树中的“或”和“与”节点是<strong>逐层交替</strong>出现的 3. 整个博弈过程是<strong>站在某一方的立场上</strong>的，自己获胜的节点是可解节点，对方获胜的是不可解节点</p><h4 id="极大极小过程">极大/极小过程</h4><p>一些基本引入思考： - 对于复杂的博弈问题，不可能生成整个搜索树 - 一种可行的方法是用当前正在考察的节点生成一棵部分博弈树 - 利用估价函数 <span class="math inline">\(f(n)\)</span> 对叶节点进行静态估值</p><p>估值的方法是？ 叶子节点： - 对 MAX 有利的节点，估价函数取正 - 对 MIN 有利的节点，估价函数取负 - 双方均等的节点，估价函数接近 0 非叶子节点： - MAX 节点： - 由于 MAX 方总是选择估值最大的走步 - MAX 节点的倒推值应该取其后继节点估值的最大值 - MIN 节点： - MIN 方总是选择使估值最小的走步 - MIN 节点的倒推值应取其后继节点估值的最小值 这样一步一步的计算倒推值，直至求出初始节点的倒推值为止。这一过程称为<strong>极大极小过程</strong></p><figure><img src="/imgs/AI/搜索/极大极小搜索的例子.png" alt="使用例" /><figcaption>使用例</figcaption></figure><h4 id="alpha--beta-剪枝"><span class="math inline">\(\alpha -\beta\)</span> 剪枝</h4><p>极大/极小过程是先生成与/或树，再计算估值，所以搜索效率低（😅） 那么边生成节点边对节点估值，就可以剪去一些没用的分支，这种技术就是 <span class="math inline">\(\alpha -\beta\)</span> 剪枝。</p><p>它的方法和规则如下： 剪枝方法： - MAX 节点（或节点）的 <span class="math inline">\(\alpha\)</span> 值为当前子节点的最大倒推值； - MIN 节点（与节点）的 <span class="math inline">\(\beta\)</span> 值为当前子节点的最小倒推值； 剪枝的规则： <span class="math inline">\(\beta\)</span> 剪枝 任何 MAX 节点 n 的 <span class="math inline">\(\alpha\)</span> 值大于或等于它先辈节点的 <span class="math inline">\(\beta\)</span> 值，则 n 以下的分枝可停止搜索，并令节点 n 的倒推值为 <span class="math inline">\(\alpha\)</span> 。这种枝称为 <span class="math inline">\(\beta\)</span> 剪枝。</p><p><span class="math inline">\(\alpha\)</span> 剪枝 任何 MIN 节点 n 的 <span class="math inline">\(\beta\)</span> 值小于或等于它先辈节点的 <span class="math inline">\(\alpha\)</span> 值，则n以下的分枝可停止搜索，并令节点 n 的倒推值为 <span class="math inline">\(\beta\)</span> 。这种枝称为 <span class="math inline">\(\alpha\)</span> 剪枝。</p><figure><img src="/imgs/AI/搜索/alphabeta剪枝使用例.png" alt="使用例" /><figcaption>使用例</figcaption></figure><h2 id="conclusion">Conclusion</h2><p>状态空间搜索的很多都是老朋友了，但是这里需要着重注意一下数学方法相关的内容！ 还要注意的是：例题里的搜索顺序和解的理解。 （搜索顺序：扩展节点顺序，解：路径）</p><p>至于那两个树搜索，注意概念和定义过程吧！</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能 确定性推理</title>
    <link href="/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/"/>
    <url>/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">Intro</h2><ul><li>掌握几种不同的推理方法</li><li>掌握一阶谓词逻辑基础、置换与合一的概念，掌握求取最一般合一置换的方法。</li><li>掌握归结原理及归结推理方法。</li><li>掌握利用归结原理进行定理证明的方法。</li><li>掌握利用归结原理进行问题求解的方法。</li><li>了解归结过程中的控制策略。</li></ul><p>涉及到的推理大概这几种： - 产生式推理 - 自然演绎推理 - 归结演绎推理</p><p>什么是推理？ 推理就是<strong>按照某种策略从已有事实和知识推出结论的过程</strong></p><p>推理的分类： 从逻辑分类： - 演绎推理 - 一般到个别的推理 - 常用：三段论 - 不能增殖新知识 - 归纳推理 - 大量事例归纳出一般的过程 - 从个别到一般 - 增殖新知识 &gt; 例如，一位计算机维修员，从书本知识，到通过大量实例积累经验，是一种归纳推理方式。运用这些一般性知识去维修计算机的过程则是演绎推理。</p><p>按确定性分类： - 确定性推理 - 不确定性推理</p><p>是否具有启发性分类： - 启发式推理 - 运用与问题有关的启发性知识 - 加快推理过程，提高推理效率 - 非启发式推理 - 按照一般模式推理 - 组合爆炸</p><h2 id="main">Main</h2><h3 id="产生式推理">产生式推理</h3><p>产生是系统的基本结构； 综合数据库 DB - 存放与求解问题有关的各种当前信息 - eg: 初始状态、输入的事实、推理得到的中间结论和最终结论 规则库 RB - 存放与求解问题有关的规则集合 - 包含将初始状态转换成目标状态需要的变换规则 控制系统 Control System - 推理机 - 初始数据库、选择规则、执行规则、推理、结束</p><p>推理过程： (1) 正向推理的特性 正向推理的主要优点是比较直观，主要缺点是推理无明确的目标，求解问题时可能会执行许多与解无关的操作，导致推理效率较低。</p><ol start="2" type="1"><li><p>逆向推理的特性 逆向推理的主要优点是不必寻找和使用那些与假设目标无关的信息和规则，推理过程的目标明确，主要缺点是当用户对解的情况认识不清时，由系统自主选择假设目标的盲目性比较大，若选择不好，会影响系统效率。</p></li><li><p>双向推理方法 为互相取长补短，可以把正向和逆向结合起来使用，采用双向推理的方式。双向推理有多种不同的实现方法，可以采用先正向后逆向，也可以采用先逆向后正向，还可以采用随机选择正向和逆向的推理方法。</p></li><li><p>推理过程的不唯一性 从前面的推理算法可以看出，无论是正向推理还是逆向推理，当可用规则集中有多条规则可用时，不同的冲突消解策略将导致不同的规则使用顺序， 因此其推理过程是不唯一的。</p></li></ol><!-- 考虑什么时候补一下推理（正向反向的那些） --><h3 id="自然演绎推理">自然演绎推理</h3><p>关键词：置换与合一 <img src="/imgs/AI/确定性推理/置换与合一.png" alt="置换与合一" /></p><p>逻辑基础：等价式、永真蕴含式、置换与合一。</p><p>等价式： 其实就是和数理逻辑那些差不多，简单举几个例子就明白了！ - 双重否定律： $ P P$ - 交换律： $P Q Q P, P Q Q P $ - 结合律： $ (P Q) R P (Q R)$ - 分配律： <span class="math inline">\(P \vee (Q \wedge R) \Leftrightarrow (P \vee Q) \wedge (P \vee R)\)</span> - 摩根律： <span class="math inline">\(\neg (P \vee Q) \Leftrightarrow \neg P \wedge \neg Q\)</span> - and so on ...</p><p>永真蕴含式： 就是永真的蕴含式。 <span class="math inline">\(P \rightarrow Q\)</span> 永真，记作 <span class="math inline">\(P \Rightarrow Q\)</span>。 <span class="math inline">\(Q\)</span> 是 <span class="math inline">\(P\)</span> 的逻辑结论， <span class="math inline">\(P\)</span> 是 <span class="math inline">\(Q\)</span> 的前提。</p><p>置换与合一上面有。 但是这里需要给出形式化的定义: <img src="/imgs/AI/确定性推理/置换的形式化定义.png" alt="置换的形式化定义" /></p><p>置换的合成: <span class="math inline">\(\theta = \{t_1/x_1, t_2/x_2, ... , t_n/x_n\}\)</span> 和 <span class="math inline">\(\lambda = \{u_1/y_1, u_2/y_2, ... , u_n/y_n\}\)</span> 是两个置换，那么它们的合成 <span class="math inline">\(\theta \circ \lambda\)</span> 也是置换，其实现为： 从 <span class="math inline">\(\{t_1\lambda / x_1, t_2\lambda / x_2, ... , t_n \lambda / x_n, u_1/y_1, u_2/y_2, ... , u_n/y_n\}\)</span> 中，删去如下两种形式的元素： <span class="math display">\[1. \quad t_i \lambda = x_i , \quad delete \ \ t_i \lambda / x_i\\2. \quad y_j \in \{x_1, x_2, ... , x_n\}, \quad delete \ \ u_j/y_j\]</span> 通俗一点的话来说呢，就是： 1. 叠起来， 2. 对于前一半，如果俩长得一样，就删了， 3. 对于后一半，如果后面那个在前面那一半里出现过，也删了。</p><p>合一： <img src="/imgs/AI/确定性推理/合一的定义.png" alt="合一的定义" /> 利用<strong>置换</strong>，使得两个或多个谓词的<strong>个体一致</strong></p><p>最一般合一： 设 <span class="math inline">\(\sigma\)</span> 是谓词公式集 <span class="math inline">\(F\)</span> 的一个合一置换，如果对 <span class="math inline">\(F\)</span> 的任意一个合一置换 <span class="math inline">\(\theta\)</span> 都存在一个置换 <span class="math inline">\(\lambda\)</span>，使得 <span class="math inline">\(\theta = \sigma · \lambda\)</span>，则称 <span class="math inline">\(\sigma\)</span> 是一个最一般（或最简单）合一置换。</p><p><strong>一个公式集的最一般合一是唯一的。</strong></p><p>最一般合一的实例： 设 <span class="math inline">\(S=\{P(x,y,f(y)), P(w, g(x), z)\}\)</span> <span class="math inline">\(S\)</span> 有一个最一般合一置换： <span class="math inline">\(\sigma = \{ w/x, g(w), f(g(w))/z \}\)</span> 对于 <span class="math inline">\(S\)</span> 的任一合一置换，例如： <span class="math inline">\(\theta=\{ u/x, g(u)/y, f(g(u)) /z, u/w\}\)</span> 存在一个替换：<span class="math inline">\(\lambda = \{ u/w \}\)</span> 使得 <span class="math inline">\(\theta = \sigma · \lambda\)</span></p><p>关于最一般合一置换的求取有： <img src="/imgs/AI/确定性推理/差异集.png" alt="差异集" /></p><figure><img src="/imgs/AI/确定性推理/差异集例子.png" alt="差异集例" /><figcaption>差异集例</figcaption></figure><figure><img src="/imgs/AI/确定性推理/最一般合一置换求取.png" alt="最一般合一置换求取算法" /><figcaption>最一般合一置换求取算法</figcaption></figure><p>最一般合一例： 1. 普通流程 <img src="/imgs/AI/确定性推理/最一般合一置换例1.1.png" alt="最一般合一置换例1-1" /> <img src="/imgs/AI/确定性推理/最一般合一置换例1.2.png" alt="最一般合一置换例1-2" /> 2. 变元在项里出现了！ <img src="/imgs/AI/确定性推理/最一般合一置换例2.png" alt="最一般合一置换例2" /></p><h3 id="归结演绎推理">归结演绎推理</h3><p><strong>什么是归结演绎推理？</strong> 归结演绎推理是一种基于鲁宾逊 (Robinson) 归结原理的机器推理技术。鲁宾逊归结原理亦称为消解原理，是鲁宾逊于 1965 年在海伯伦 (Herbrand) 理论的基础上提出的一种基于逻辑的“反证法”。</p><p><strong>定理证明的实质:</strong> 就是要对前提 <span class="math inline">\(P\)</span> 和结论 <span class="math inline">\(Q\)</span> ，证明 <span class="math inline">\(P\rightarrow Q\)</span> 永真。 即要证明 <span class="math inline">\(P \rightarrow Q\)</span> 永真， 只要能够证明P∧﹁Q <span class="math inline">\(P \wedge \neg Q\)</span> 是不可满足的就可以 （原因是 <span class="math inline">\(\neg (P \rightarrow Q) \Leftrightarrow \neg (\neg P \vee Q) \Leftrightarrow P\wedge \neg Q\)</span>）</p><p>至于什么子句集化简的，回忆数理逻辑吧！</p><p>语义树： <img src="/imgs/AI/确定性推理/语义树.png" alt="语义树" /> 封闭语义树： <img src="/imgs/AI/确定性推理/封闭语义树.png" alt="封闭语义树" /></p><p>例题： <img src="/imgs/AI/确定性推理/2.39-0.png" alt="2.39-0" /> <img src="/imgs/AI/确定性推理/2.39-1.png" alt="2.39-1" /> <img src="/imgs/AI/确定性推理/2.39-2.png" alt="2.39-2" /></p><p><img src="/imgs/AI/确定性推理/2.41-0.png" alt="2.41-0" /> <img src="/imgs/AI/确定性推理/2.41-1.png" alt="2.41-1" /></p><h2 id="conclusion">Conclusion</h2><p>内容比较多和杂，需要细细捋一遍。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>确定性推理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能 知识表示</title>
    <link href="/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/"/>
    <url>/2022/04/25/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>在这里也简单地提一提绪论的内容吧！ 人工智能的研究内容： 知识： - 如何获取知识 - 如何将获取的知识以计算机内部代码的形式加以合理表示 - 如何运用知识进行推理，解决实际问题？</p><p>本章的内容是人工智能的知识表示： 主要是： - 知识与知识表示基本概念 - 一阶谓词逻辑表示法 - 产生式规则表示法 - 语义网络表示法 - 框架表示法</p><p>本章的学习要点是： &gt; - 了解知识、信息和数据的概念，以及它们之间的关系。 &gt; - 了解知识的特性、分类及它们的表示方法。 &gt; - 掌握各种知识表示法表示知识的步骤和方法。 &gt; - 了解各种知识表示方法具体表示形式的优缺点及适宜的应用对象。</p><h2 id="main">Main</h2><h3 id="知识与知识表示">知识与知识表示</h3><p>首先是什么是知识？ - <strong>知识</strong>是人类<strong>智能</strong>的基础 - 人工智能学科研究的三个主要问题 - 知识的获取 - 知识的表示 - 运用知识进行推理</p><p>那么知识和信息、数据的关系又是如何呢？ - 数据 - 是记录信息的符号，是信息的载体和表示 - 信息 - 是对数据的表示，是其在具体场合下的具体含义 - 把有关信息关联在一起所形成的信息结构称为知识 - 有格式的数据 -&gt; 信息 -&gt; 知识</p><p>在知识金字塔的结构： 噪声 -&gt; 数据 -&gt; 信息 -&gt; 知识 -&gt; 元知识</p><p>So what's 元知识？ - 元知识就是使用知识的知识 - eg: 金价目前较低，且即将上涨，那么购买黄金，这就是元知识</p><p>那么知道了什么是知识，知识表示又是什么？ - 面向计算机的知识描述或表达的形式和方法 - 就是把知识编码成某种数据结构的过程</p><p>知识表示的方法： - 逻辑谓词表示 - 产生式表示 - 语义网络表示 - 框架表示</p><h3 id="一阶谓词逻辑表示法">一阶谓词逻辑表示法</h3><p>一阶谓词逻辑表示法源于<strong>数理逻辑</strong>。</p><p>知识表示的逻辑基础包括： - 命题 - 谓词 - 连词 - 量词 - 谓词公式</p><h4 id="命题">命题</h4><p>这个是比较常见的概念了，不表。</p><h4 id="谓词">谓词</h4><p>论域 - 论域是讨论对象的全体构成的集合 - 论语中的元素称为个体</p><p>谓词逻辑中，命题是用谓词表示的，谓词可以分为谓词名和个体两部分， 个体是主语，谓词是谓语。</p><p>谓词和函数的区别： 谓词有真值表示真假，但是函数没有真值一说，其值是个体域中的个体； 谓词实现个体域中个体到 T 或 F 的映射。 函数实现的是同一个个体域到另一个个体域的映射。 且在谓词逻辑中，函数本身不能够单独使用，必须嵌入到谓词之中。</p><p>一般的形式是： 谓词：<span class="math inline">\(P(x_1, x_2, ... , x_n)\)</span> 函数：<span class="math inline">\(f(x_1, x_2, ... , x_n)\)</span></p><h4 id="连接词和量词">连接词和量词</h4><p>连接词： - <span class="math inline">\(\neg\)</span>：否定（非） - <span class="math inline">\(\vee\)</span>：合取（与） - <span class="math inline">\(\wedge\)</span>：析取（或） - <span class="math inline">\(\rightarrow\)</span>：蕴含 - <span class="math inline">\(\leftrightarrow\)</span>：等价</p><p>量词： - <span class="math inline">\(\forall\)</span>：全称量词 - <span class="math inline">\(\exists\)</span>：存在量词</p><h4 id="指导变元自由变元和约束变元">指导变元、自由变元和约束变元</h4><p>一般来说，辖域指的是： - 量词后的单个谓词 - “（）”起来的合式公式</p><p>指导变元：量词后面的变元称为量词的指导变元； 约束变元：辖域内的与指导变元相同的变元为约束变元 自由变元：辖域外为自由变元</p><blockquote><p><span class="math inline">\((\forall x)(P(x, y) \rightarrow Q(x, y)) \vee R(x,y)\)</span> 其中 <span class="math inline">\((P(x, y) \rightarrow Q(x, y))\)</span> 是 <span class="math inline">\((\forall x)\)</span> 的辖域，辖域内的 <span class="math inline">\(x\)</span> 是约束变元，辖域外的是自由变元。</p></blockquote><p>【改名规则】 一个变元在一个谓词公式中既可约束出现，又可自由出现，为了避免混淆，通常通过改名规则，使得一个谓词公式中一个变元仅以一种形式出现。</p><p>【换名规则】 在谓词公式中，将某量词辖域中出现的某个<strong>约束变元以及对应的指导变元</strong>更改为本辖域中没有出现过的个体变元符号，公式其它部分不变，谓词公式的等价性不变。</p><p>【代替规则】 在谓词公式中，将某量词辖域中出现的某个<strong>自由变元</strong>的所有出现用本辖域中未曾出现过的某个个体变元符号代替，谓词公式的等价性不变。</p><figure><img src="/imgs/AI/知识表示/应用实例.png" alt="应用实例" /><figcaption>应用实例</figcaption></figure><h4 id="例题">例题</h4><p>关于谓词表示，太简单的就不上了，直接来经典机器人移积木吧！</p><p><img src="/imgs/AI/知识表示/robot_1.png" alt="机器人移积木——题目" /> <img src="/imgs/AI/知识表示/robot_2.png" alt="机器人移积木——解(1)" /> <img src="/imgs/AI/知识表示/robot_3.png" alt="机器人移积木——解(2)" /> <img src="/imgs/AI/知识表示/robot_4.png" alt="机器人移积木——解(3)" /> 过程就是： 状态 -&gt; 操作 -&gt; 求解 - 状态：谓词和个体域 - 操作：条件和动作 - 条件：状态 - 动作：删除、添加表 - 求解：状态经过操作的变化</p><h4 id="优缺点">优缺点</h4><p>优点： - 严密 - 自然 - 通用 - 易于实现</p><p>缺点： - 知识表达能力差（不便于非确定性的表示和启发式知识） - 组合爆炸 - 效率低</p><h3 id="产生式规则表示法">产生式规则表示法</h3><p>专家系统的基本表示法。 适合表示<strong>事实性知识</strong>和<strong>规则性知识</strong>。 容易描述事实、规则和它们的不确定性度量。</p><h4 id="事实的表示">事实的表示</h4><p>事实通常以三元组或四元组来表示： （对象，属性，值） 或 （关系，对象1，对象2) 其中，对象就是语言变量，这种表示方式，在机器内部可以以一个表实现。</p><p>对于非确定性事实，可以（对象，属性，值，可信度因子）</p><h4 id="规则的表示">规则的表示</h4><p>规则式的基本形式 <span class="math display">\[P \rightarrow Q \\or \\IF \quad P \quad THEN \quad Q\]</span></p><figure><img src="/imgs/AI/知识表示/产生式表示法.png" alt="产生式表示法" /><figcaption>产生式表示法</figcaption></figure><h3 id="语义网络表示法">语义网络表示法</h3><p>什么是语义网络？ 它是通过概念及语义关系来表示知识的一种网络图，它是一个带标注的有向图。 - 图中的各个<strong>节点</strong>表示各种概念、事物、对象、行为、状态等； - 图中的<strong>有向弧</strong>表示节点间的联系或关系。 基本的语义单元——语义基元： （节点1，弧，节点2） 把多个基本网元用相应的语义联系关联在一起时，就可得到一个语义网络。 语义网络中的节点还可以是一个语义子网络，所以，语义网络实质上是一种多层次的嵌套结构 举个例子： <img src="/imgs/AI/知识表示/语义网络使用例.png" alt="语义网络使用例" /></p><p>基本的语义关系有： - 实例关系：ISA - 分类关系：AKO - 成员关系：A-Member-of - 聚类关系：Part-of - 属性关系：Have, Can - 时间关系：Before, After - 位置关系：Locate-on/under/at/inside/outside - 相近关系：Similar-to, Near-to</p><p>语义网络推理 <img src="/imgs/AI/知识表示/语义网络推理题目.png" alt="语义网络推理题目" /> <img src="/imgs/AI/知识表示/语义网络推理解答.png" alt="语义网络推理解答" /></p><h3 id="框架表示法">框架表示法</h3><p>感觉框架类class &gt; 框架: 是人们认识事物的一种通用的数据结构形式。即当新情况发生时， &gt; 人们只要把新的数据加入到该通用数据结构中，便可形成一个具体的<strong>实体(类)</strong>，这样的通用数据结构就称为框架。 &gt; 实例框架: 对于一个框架，当人们才把观察或认识到的具体细节填入后，就得到了该框架的一个具体实例，框架的这种具体实例被称为实例框架. &gt; 框架系统: 在框架理论中，框架是知识的基本单位，把一组有关的框架连结起来使可形成一个框架系统. &gt; 框架系统推理: 由框架之间的协调来完成.</p><figure><img src="/imgs/AI/知识表示/框架的结构.png" alt="框架结构" /><figcaption>框架结构</figcaption></figure><p>例题： 假设有以下一段天气预报：“北京地区今天白天晴，偏北风3级，最高气温12◦，最低气温-2◦，降水概率15%。”请用框架表示这一知识。 解： <figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bnf">Frame<span class="hljs-attribute">&lt;天气预报&gt;</span><br>    地区：北京<br>    时段：今天白天<br>    风向：偏北风<br>    风力：3级<br>    温度：<br>        最高温度：12°<br>        最低温度：-2°<br>    降水概率：15%<br></code></pre></td></tr></table></figure></p><h2 id="conclusion">Conclusion</h2><p>知识表示也就这么几种吧！ 总之学会表示后就应该推理了！</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>知识表示</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.6 应用层</title>
    <link href="/2022/04/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-6-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2022/04/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-6-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><p>本章学习目标 - 掌握网络应用体系结构 - 理解网络应用通信原理 - 掌握域名系统及域名解析过程 - 掌握FTP应用及应用层协议 - 掌握email应用及应用层协议 - 掌握Web应用及应用层协议 - 掌握Web响应时间优化方案 - 掌握P2P应用原理及特点 - 掌握P2P文件分发原理 - 掌握P2P索引技术 - 掌握Socket编程技术</p><h2 id="内容">内容</h2><h3 id="网络应用体系结构">网络应用体系结构</h3><ul><li>客户端/服务器结构 (Client-Server, C/S)</li><li>点对点结构 (Peer-to-Peer P2P)</li><li>混合结构 (Hybrid)</li></ul><h4 id="cs-架构">C/S 架构</h4><p>服务器 (server) - 7*24 小时提供服务 - 永久性可访问地址/域名 - 利用大量服务器实现可扩展性 客户机 (client) - 与服务器通信，使用服务器提供的服务 - 间歇性接入网络 - 可能使用动态 IP 地址 - 不会与其他客户机直接通信</p><h3 id="网络应用通信原理">网络应用通信原理</h3><h3 id="域名解析系统-dns">域名解析系统 DNS</h3><h4 id="section"></h4><h4 id="本地域名服务器">本地域名服务器</h4><ul><li>不严格属于层级体系</li><li>每个 ISP</li></ul><h4 id="dns-根域名服务器">DNS 根域名服务器</h4><ul><li>本地查不到就查根域名</li><li>根域名服务器<ul><li>获得映射</li><li>全球有 13 个</li></ul></li></ul><h4 id="tld-和权威域名解析服务器">TLD 和权威域名解析服务器</h4><ul><li>顶级域名服务器 (TLD, Top Level Domain)<ul><li>负责 com、org、net、edu 等顶级域名和国家顶级域名</li><li>Network Solution 维护 com</li><li>Educase 维护 edu</li></ul></li><li>权威域名服务器<ul><li>负责组织内部</li><li>组织负责维护</li><li>服务提供商负责维护</li></ul></li></ul><h4 id="dns-查询过程">DNS 查询过程</h4><p>递归查询： <!-- 图之后补 --> 迭代查询</p><h4 id="注册域名">注册域名</h4><h3 id="ftp-应用">FTP 应用</h3><h3 id="email-应用">Email 应用</h3><p>构成组件： - 邮件客户端 - 邮件服务器 - SMTP 协议</p><p>邮件客户端（用户代理）： - 读、写消息 - 与服务器交互，收发</p><p>邮件服务器： - 邮箱：存储发给该用户的 Email - 消息队列：存储等待发送的 Email</p><p>SMTP 协议： - 邮件服务器直接传递消息所使用的协议 - 客户端： - 服务器： - 采用 TCP 实现可靠传输 - 服务器端口号——25 - 传输三阶段 - 握手 - 消息传输 - 关闭 - 命令/响应交互模式 - 命令： - 响应： - Email 信息只能包含 7 比特 ASCII 码</p><h3 id="web-应用">Web 应用</h3><h3 id="p2p-应用">P2P 应用</h3><h3 id="socket-编程">Socket 编程</h3><h2 id="总结">总结</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能 不确定性推理</title>
    <link href="/2022/04/13/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/"/>
    <url>/2022/04/13/ArtificialIntelligence/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>这部分的内容不会很细致，主要是一些知识点的记录</p><h2 id="main">Main</h2><h3 id="可信度推理">可信度推理</h3><ul><li>可信度推理模型也称为 CF(Certainty Factor) 模型</li><li>CF 模型中，一般形式为<ul><li><span class="math inline">\(IF \quad E \quad THEN \quad H(CF(H,E))\)</span></li><li><span class="math inline">\(E\)</span> 是知识的前提，<span class="math inline">\(H\)</span> 是知识的结论；<span class="math inline">\(CF(H,E)\)</span> 是知识的可信度</li><li><span class="math inline">\(E\)</span> 可以是简单条件也可是复合条件</li><li><span class="math inline">\(H\)</span> 可以是单一结论也可以是多个结论</li><li><span class="math inline">\(CF\)</span> 即可信度因子，常简称为可信度或规则强度，是知识的静态强度</li><li><span class="math inline">\(CF(H,E)\)</span> 通常的取值范围 <span class="math inline">\([-1,1]\)</span></li><li><span class="math inline">\(CF(H,E)\)</span> 的值越大，说明 <span class="math inline">\(E\)</span> 对结论 <span class="math inline">\(H\)</span> 的支持程度越大</li></ul></li><li>在 <span class="math inline">\(CF\)</span> 模型中 <span class="math inline">\(CF(H,E)\)</span> 定义为：<span class="math inline">\(CF(H,E)=MB(H,E)-MD(H,E)\)</span><ul><li><span class="math inline">\(MB\)</span> (Measure Belief) 是信任增长度，表示 <span class="math inline">\(E\)</span> 的出现，<span class="math inline">\(H\)</span> 为真的信任增长度</li><li><span class="math display">\[  MB(H,E) = \left\{  \begin{array}{c}  1 &amp; P(H) = 1\\   \dfrac{max\{P(H|E),P(H)\} - P(H)}{1-P(H)} &amp; 其他   \end{array}\right.  \]</span></li><li><span class="math inline">\(MD\)</span> (Measure Disbelief) 是不信任增长度，表示 <span class="math inline">\(E\)</span> 的出现，<span class="math inline">\(H\)</span> 为假的信任增长度</li><li><span class="math inline">\(MD(H,E) = \left\{\begin{array}{c} 1 &amp; P(H) = 0\\ \dfrac{max\{P(H|E),P(H)\} - P(H)}{-P(H)} &amp; 其他 \end{array}\right.\)</span></li><li><span class="math inline">\(CF(H,E) = \left\{\begin{array}{c} MB(H,E) - 1 = \dfrac{P(H|E)-P(H)}{1-P(H)} &amp; P(H|E) &gt; P(H) \\ 0 &amp; P(H|E) = P(H) \\ 0 - MD(H,E) = -\dfrac{P(H)-P(H|E)}{P(H)} &amp; P(H|E)&lt;P(H) \end{array} \right.\)</span></li><li>值域：<span class="math inline">\(\left\{\begin{array}{l} 0 \le MB(H,E) \le 1 \\ 0 \le MD(H,E) \le 1 \\ -1 \le CF(H,E) \le 1 \end{array} \right.\)</span></li><li><span class="math inline">\(\sum^{n}_{i=1}CF(H_i,E) \le 1\)</span></li></ul></li><li><span class="math inline">\(CF(E)\)</span> 的值有这样的含义：<ul><li><span class="math inline">\(CF(E) = 1\)</span> 证据 <span class="math inline">\(E\)</span> 肯定为真</li><li><span class="math inline">\(CF(E) = -1\)</span> 证据 <span class="math inline">\(E\)</span> 肯定为假</li><li><span class="math inline">\(CF(E) = 0\)</span> 对证据 <span class="math inline">\(E\)</span> 一无所知</li><li><span class="math inline">\(0 &lt; CF(E) &lt; 1\)</span> 证据 <span class="math inline">\(E\)</span> 以 <span class="math inline">\(CF(E)\)</span> 程度为真</li><li><span class="math inline">\(-1 &lt; CF(E) &lt;0\)</span> 证据 <span class="math inline">\(E\)</span> 以 <span class="math inline">\(CF(E)\)</span> 程度为假</li></ul></li><li>组合证据不确定性：<ul><li>多个证据合取 <span class="math inline">\(AND\)</span>，取最小值</li><li>多个证据析取 <span class="math inline">\(OR\)</span>，取最大值</li></ul></li><li>不确定性的更新：<ul><li><span class="math inline">\(CF(H) = CF(H,E)\times max\{0, CF(E)\}\)</span></li></ul></li><li>结论不确定性的合成<ul><li>假设有如下知识 </br> <span class="math inline">\(IF \quad E_1 \quad H \quad (CF(H,E_1))\)</span> </br> <span class="math inline">\(IF \quad E_2 \quad H \quad (CF(H,E_2))\)</span> </br> 则: </br> <span class="math inline">\(CF_1(H) = CF(H,E_1) \cdot max\{0,CF(E_1)\}\)</span> </br> <span class="math inline">\(CF_2(H) = CF(H,E_2) \cdot max\{0,CF(E_2)\}\)</span> </br> 综合可信度：</br> <span class="math inline">\(CF(H) = \left\{ \begin{array}{c} CF_1(H) + CF_2(H) - CF_1(H)CF_2(H) &amp; 若CF_1(H) \ge 0 且 CF_2(H) \ge 0 \\ CF_1(H) + CF_2(H) + CF_1(H)CF_2(H) &amp; 若CF_1(H)&lt;0且CF_2(H)&lt;0 \\ \dfrac{CF_1(H) + CF_2(H)}{1-min\{|CF_1(H)|,|CF_2(H)|\}} &amp; 若CF_1(H)和CF_2(H)异号 \end{array} \right.\)</span> ### 可信度推理的例子 设有如下一组知识： <span class="math display">\[ \begin{array}{l}r_1:\ IF \quad E_1 \quad THEN \quad H \quad (0.9) \\r_2:\ IF \quad E_2 \quad THEN \quad H \quad (0.6) \\r_3:\ IF \quad E_3 \quad THEN \quad H \quad (-0.5) \\r_4:\ IF \quad E_4 \ AND \ (E_4 \ OR \ E_6) \quad THEN \quad E_1 \quad (0.8) \\且：CF(E_2) = 0.8,CF(E_3)=0.6,CF(E_4)=0.5,CF(E_5)=0.6,CF(E_6)=0.8 \\ 求：CF(H)\end{array}\]</span></li></ul></li></ul><p><span class="math display">\[ \begin{array}{l}解：\\由r_4得 \\CF(E_1) = 0.8 \times max \{ 0, CF(E_4 \quad AND \quad (E_5 \quad OR \quad E_6)) \} \\\quad\quad\quad\ \begin{array}{l}= 0.8 \times max \{ 0, min\{CF(E_4) ,CF(E_5 \ OR \ E_6)\} \} \\= 0.8 \times max \{ 0, min \{ CF(E_4), max\{ CF(E_5) , CF(E_6) \} \} \} \\= 0.8 \times max \{ 0, min \{CF(E_4), max \{0.6, 0.8\} \} \} \\= 0.8 \times max \{0, min \{ 0.5, 0.8 \} \} \\= 0.8 \times 0.5 \\= 0.4\end{array}\\由 r_1 得 \\CF_1(H) = CF(H, E_1) \times max \{ 0, CF(E_1) \}  = 0.9 \times max \{ 0, 0.4 \} = 0.36\\由r_2得 \\CF_2(H) = CF(H,E_2) \times max \{ 0, CF(E_2) \} = 0.6 \times max \{ 0, 0.8 \} = 0.48\\由r_3得 \\CF_3(H) = CF(H, E_3) \times max \{ 0, CF(E_3) \} = -0.5 \times max \{ 0, 0.6 \} = -0.3\\由结论不确定的合成算法得：\\CF_{1,2}(H) = CF_1(H) + CF_2(H) - CF_1(H)CF_2(H) = 0.36+0.48 - 0.36 \times 0.48 = 0.67\\CF_{1,2,3}(H) = \dfrac{CF_{1,2}(H)+CF_3(H)}{1-min\{|CF_{1,2}(H)|,|CF_3(H)|\}}=\dfrac{0.67-0.3}{1-min\{0.67,0.3\}}=0.53 \\\therefore\ 综合可信度CF(H)=0.53\end{array}\]</span></p><h3 id="主观-bayes-推理">主观 Bayes 推理</h3><p><del>虽然不是很重要但是还是记一下：主观 Bayes 方法不是贝叶斯的，是杜达 (R.O.Duda) 等人于 1976 年提出的</del> #### 全概率公式和贝叶斯公式 全概率公式： <span class="math inline">\(P(B) = \sum^n_iP(A_i) \times P(B|A_i)\)</span> （任意事件互不相容）</p><p>Bayes 公式： <span class="math inline">\(P(A_i|B) = \dfrac{P(A_i) \times P(B|A_i)}{\sum^n_{j=1}P(A_j) \times P(B|A_j)}\)</span></p><p>两者结合： <span class="math inline">\(P(A_i|B) = \dfrac{P(A_i)\cdot P(B|A_i)}{P(B)}, (i = 1,2,...,n)\)</span> 即： <span class="math inline">\(P(A_i|B) \cdot P(B) = P(B|A_i) \cdot P(A_i), (i = 1,2,...,n)\)</span> Bayes 公式实际上是一种用逆概率 <span class="math inline">\(P(B|A_i)\)</span> 求原概率 <span class="math inline">\(P(A_i|B)\)</span> 的方法。</p><h4 id="主观-bayes-方法的推理模型">主观 Bayes 方法的推理模型</h4><p>知识不确定性表示： <span class="math inline">\(IF \quad E \quad THEN \quad (LS, LN) \quad H\)</span> - 其中 <span class="math inline">\((LS, LN)\)</span> 用来表示该知识的知识强度 - <span class="math inline">\(LS = \dfrac{P(E|H)}{P(E|\neg H)}\)</span> - <span class="math inline">\(LN = \dfrac{P(\neg E|H)}{P(\neg E| \neg H)} = \dfrac{1-P(E|H)}{1-P(E|\neg H)}\)</span> - <span class="math inline">\(LS, LN \in [0, +\infty)\)</span></p><p><span class="math inline">\(LS\)</span> 和 <span class="math inline">\(LN\)</span> 的含义： 由 Bayes 公式有：</p><p><span class="math inline">\(P(H|E) = \dfrac{P(E|H)P(H)}{P(E)} \\ P(\neg H|E) = \dfrac{P(E|\neg H) P(\neg H)}{P(E)}\)</span></p><p>两式相除</p><p><span class="math inline">\(\dfrac{P(H|E)}{P(\neg H|E)} = \dfrac{P(E|H)}{P(E|\neg H)} \times \dfrac{P(H)}{P(\neg H)}\)</span></p><p>为了讨论方便，引入几率函数：</p><p><span class="math inline">\(O(X) = \dfrac{P(X)}{1-P(X)} = \dfrac{P(X)}{P(\neg X)}\)</span></p><p>它的意义是将 <span class="math inline">\([0,1]\)</span> 的 <span class="math inline">\(P(X)\)</span> 放大到 <span class="math inline">\([0, +\infty)\)</span></p><p>将这个几率函数代入，有：</p><p><span class="math inline">\(O(H|E) = \dfrac{P(E|H)}{P(E|\neg H)} O(H)\)</span></p><p>还可以再带入 <span class="math inline">\(LS\)</span> 和 <span class="math inline">\(LN\)</span></p><p><span class="math inline">\(O(H|E) = LS \times O(H) \\ O(H|\neg E) = LN \times O(H)\)</span></p><p><span class="math inline">\(LS\)</span> 的性质： <img src="/imgs/AI/不确定性推理/LS的性质.png" alt="LS的性质" /></p><p><span class="math inline">\(LN\)</span> 的性质： <img src="/imgs/AI/不确定性推理/LN的性质.png" alt="LN的性质" /></p><h4 id="证据不确定性的表示">证据不确定性的表示</h4><p>基本证据表示： <span class="math inline">\(O(E) = \dfrac{P(E)}{1-P(E)} = \left\{ \begin{array}{l} 0 &amp; E为假 \\ \infty &amp; E为真 \\ (0, +\infty) &amp; E非真也非假 \end{array} \right.\)</span></p><p>组合证据不确定性： - 多个证据合取 <span class="math inline">\(AND\)</span>，取最小值 - 多个证据析取 <span class="math inline">\(OR\)</span>，取最大值</p><p>不确定性的更新： - 证据当前观察下肯定为真 <span class="math inline">\(O(H|E) = LS \times O(H) \\ P(H|E) = \dfrac{LS \times P(H)}{(LS-1) \times P(H) + 1}\)</span></p><ul><li><p>证据当前观察下肯定为假 <span class="math inline">\(O(H|\neg E) = N \times O(H) \\ P(H|\neg E) = \dfrac{LN \times P(H)}{(LN-1) \times P(H) + 1}\)</span></p></li><li><p>证据当前观察下非真非假 <span class="math inline">\(P(H|S)=P(H|E)P(E|S)+P(H|\neg E)P(\neg E|S)\)</span> 分不同情况有： <span class="math inline">\(P(E|S) = 1 \\ P(E|S) = P(H|E) = \dfrac{LS \times P(H)}{(LS - 1) \times P(H) + 1}\)</span> <span class="math inline">\(P(E|S) = 0 \\ P(E|S) = P(H|\neg E) = \dfrac{LS \times P(H)}{(LS-1) \times P(H) + 1}\)</span> <span class="math inline">\(P(E|S) = P(E) \\ P(E|S) = P(H|E)P(E|S)+P(H|\neg E)P(\neg E|S) \\ = P(HE|E)P(E) + P(H|\neg E)P(\neg E) = P(H)\)</span> <span class="math inline">\(P(E|S) 为其他值，可以通过上面三个特殊点的分段插值函数求得 \\ P(H|S) = \left\{ \begin{array}{l} P(H|\neg E) + \dfrac{P(H)-P(H|\neg E)}{P(E)} \times P(E|S) &amp; 0 \le P(E|S) &lt; P(E) \\ P(H) + \dfrac{P(H|E) - P(H)}{ 1-P(E)} \times [P(E|S) - P(E)] &amp; P(E) \le P(E|S) \le 1 \end{array} \right.\)</span></p></li></ul><h3 id="主观-bayes-推理的例子">主观 Bayes 推理的例子</h3><p>设有规则： $$ \begin{array}{l}</p><p>r_1: IF E_1 THEN (2, 0.001) H_1 \ r_2: IF E_1 AND E_2 THEN (100,0.001) H_1 \ r_3: IF E_1 THEN (200, 0.01) H_2 \ 已知：P(E_1)=P(E_2)=0.6, P(H_1) = 0.091, P(H_2) = 0.01 \ 用户回答：P(E_1|S_1)=0.76, P(E_2|S_2) = 0.68 \ 求：P(H_2|S1,S2)=?</p><p>\end{array} <span class="math display">\[得到推理网络图：![推理网络图](/imgs/AI/不确定性推理/推理网络.png)\]</span> \begin{array}{l} 解之前先进行分析: \ 要想得到 H_2，则先要有H_1， \ 但是需要有H_1，就要有 E_1 和 E_1  AND  E_2 \ 经过层层不确定性更新可以得到答案！ \ 解：\ (1) 计算O(H_1|S_1) \ O(H_1|S_1) =  \ 更新后验概率：P(H_1|E_1) =  =  = 0.167 \ P(E_1|S_1) = 0.76 &gt; P(E_1) \ P(H_1|S_1) = P(H_1) + (P(E_1|S_1) - P(E_1)) \ = 0.091 +  (0.76 - 0.6) = 0.121 \ O(H_1|S_1) =  = 0.138 \ (2) 计算O(H_1|(S_1  AND  S_2)) \ r_1 的前件是 E_1、E_2 的合取关系，所以仅考虑E_2对H_1的影响。\ 把H_1的先验概率P(H_1)更新为在E_2下的后验概率P(H_1|E_2) \ P(H_1 |E_2)= = =0.909 \ P(E_2|S_2) = 0.68 &gt; P(E_2) \ P(H_1|S_2)=P(H_1) +  (P(E_2|S_2)-P(E_2)) = 0.255 \ O(H_1|S_2) =  = 0.342 \ (3) 计算O(H_1|S_1, S_2)\ 将 H_1 的先验概率转换为先验几率 O(H_1) =  =  = 0.100 \ 再根据合成公式计算后验几率 \ O(H1|S1, S2) =   O(H_1) \ =   0.1s = 0.472 再将后验几率转变为后验概率 \ P(H_1|S_1, S_2) =  = =0.321 \ (4) 计算P(H_2|S_1, S_2)\ 先将H_2的先验概率P(H_2)转换为在H_1下的后验概率 \ P(H_2|H_1) =  =  = 0.669 \ P(H_1|S_1, S_2) = 0.321 &gt; P(H_1) \  P(H_2|S_1, S_2) = P(H_2) +  \ = 0.01 +  (0.321-0.091) = 0.177 \ \end{array} $$</p><h3 id="模糊推理">模糊推理</h3><h3 id="贝叶斯网络">贝叶斯网络</h3><p><del>贝叶斯网络其实也不是贝叶斯，是贝叶斯网络是由美国加州大学的珀尔 (J.Pearl)于 1985 年首先提出的一种模拟人类推理过程中因果关系的不确定性处理模型</del></p><p>贝叶斯网络是概率论与图论的集合，其拓扑结构是一个<strong>有向无环图</strong>： - 图中的节点表示问题求解中的命题或随机变量 - 有向边表示依赖关系 - 依赖关系可以用条件概率来描述 - 关于构造的过程： 1. 建立<strong>不依赖于其他节点</strong>的根节点，可以不止一个 2. 加入受根节点影响的节点作为子节点，此时根节点已为父节点 3. 进一步建立子节点，直到叶子节点 4. 对于根节点：给出先验概率；对于中间节点和叶子节点：给出条件概率表 - 关于构造的规则： 1. 忽略过于微弱的依赖关系（不一定对于每个依赖关系都要表示出来，取决于计算精度和代价之间的权衡） 2. 随机变量的因果关系是最常见直观的指导关系，可以用来指导贝叶斯网络的构建过程</p><p>定义： 设<span class="math inline">\(X = \{ X_1, X_2, ..., X_n \}\)</span> 是任何随机变量集，其上的贝叶斯网络可定义为 <span class="math inline">\(B_N=(B_S, B_P)\)</span>。其中： 1. <span class="math inline">\(B_S\)</span> 是贝叶斯网络的结构，是一个有向无环图 (DAG) 2. <span class="math inline">\(B_P\)</span> 为贝叶斯网络的条件概率集合：每节点 <span class="math inline">\(X_i\)</span> 都有一个条件概率分布表：<span class="math inline">\(P(X_i|Parents(X_i))\)</span>，量化其父节点对该节点的影响</p><p>一个贝叶斯网络的例子如下： <img src="/imgs/AI/不确定性推理/贝叶斯网络使用例.png" alt="贝叶斯网络使用例" /> 可以看出还是“很贝叶斯”的（指条件概率） 它还有计算的部分： <img src="/imgs/AI/不确定性推理/贝叶斯网络全联合概率计算.png" alt="贝叶斯网络全联合概率计算" /></p><h3 id="贝叶斯网络的推理">贝叶斯网络的推理</h3><h4 id="精确推理">精确推理</h4><p>精确推理最基本的方法是基于枚举的算法。 它是使用全联合概率分布取推断查询变量的后验概率： <span class="math inline">\(P(X|s) = \alpha P(X, s) = \alpha \sum P(X, s, Y)\)</span> 变量解释： - <span class="math inline">\(X\)</span>: 查询变量 - <span class="math inline">\(s\)</span>: 一个观察到的特定事件 - <span class="math inline">\(Y\)</span>: 隐含变量集 - <span class="math inline">\(\alpha\)</span>: 归一化常数，用于保证相对于 <span class="math inline">\(X\)</span> 所有取值的后验概率和等于1</p><p>为了对贝叶斯网络进行推理，利用贝叶斯网络的全概率公式： <span class="math inline">\(P(x_1, x_2, ... , x_n) = \prod\limits_{i-1}^n P(X_i|par(X_i))\)</span> 它的思路是将 <span class="math inline">\(P(X, s, Y)\)</span> 改写成为条件概率乘积的形式，可以通过先对 <span class="math inline">\(Y\)</span> 的各枚举值求其条件概率，再对各条件概率乘积求总和的方式去查询变量的条件概率。</p><p>具体应用可以看作业题（）</p><h4 id="近似推理">近似推理</h4><p>常用算法：马尔科夫蒙特卡罗 (MCMC) 关键在隐变量随机初始化？ 再产生一个随机数，如果结果还比随机数大，就转移状态。 转移概率的采样器称为吉布斯 (Gibbs) 采样器。</p><h2 id="conclusion">Conclusion</h2><p>原本说是写简短点的，结果还是有点长了。。 其实还是结合实例比较好理解！！</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>不确定性推理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.5 传输层</title>
    <link href="/2022/04/13/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-5-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/04/13/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-5-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><p>自此开始 <strong>端到端</strong> 的同通信原则，不关心底层网络的情形，在逻辑上关心一个端系统到端系统的通信。 向下依赖底层网络，向上为应用层提供服务。</p><p>本章学习目标 - 理解传输层服务 - 理解端到端原则 - 掌握传输层复用/分解方法 - 掌握 UDP 协议 - 掌握 TCP 协议 - TCP 协议特点 - TCP 段结构 - TCP 可靠数据传输 - TCP 流量控制 - TCP 连接控制 - TCP 拥塞控制 - TCP 公平性 预想一下重点应该在 TCP 吧，毕竟都标出来那么多了。</p><h2 id="内容">内容</h2><h3 id="传输层服务">5.1 传输层服务</h3><h4 id="协议">协议</h4><p>一些总的介绍 - 传输层协议为运行在不同 Host 上的进程提供了一种逻辑通信机制</p><ul><li>端系统运行传输层协议<ul><li>发送方：将应用递交的消息分成一 个或多个的 Segment，并向下传给网络层。</li><li>接收方：将接收到的 Segment 组装成消息，并向上交给应用层。</li></ul></li><li>传输层可以为应用提供多种协议<ul><li>TCP</li><li>UDP</li></ul></li></ul><p>TCP 和 UDP： - 可靠、按序的交付服务 (TCP) - 拥塞控制 - 流量控制 - 连接建立</p><ul><li>不可靠的交付服务 (UDP)<ul><li>基于“尽力而为的网络层”</li><li>没有做可靠性方面的扩展</li></ul></li><li>两种服务均不能保证的<ul><li>延迟</li><li>带宽</li></ul></li></ul><h4 id="与网络层对比">与网络层对比</h4><p>网络层：提供<strong>主机</strong>之间的逻辑通信机制 传输层：提供<strong>应用进程</strong>之间的逻辑通信机制 - 位于网络层之上 - 依赖于网络层服务 - 对网络层服务进行（可能的）增强</p><blockquote><p>一个类比： 12个孩子给12个家庭写信 - 应用进程——孩子 - 应用消息——信封里的信 - 主机——房子 - 传输层协议——李雷和韩梅梅（为啥啦，写信方和收信方吗） - 网络层协议——邮政服务</p></blockquote><h3 id="传输层多路复用分用">5.2 传输层多路复用/分用</h3><p>发送端： 从多个 Socket 接收数据，为每块数据封装上头部信息，生成 Segment，交给网络层</p><p>接收端： 传输层依据头部信息将收到的 Segment 交给正确的 Socket，即不同的进程</p><h3 id="udp-协议">5.3 UDP 协议</h3><h3 id="tcp-协议">5.4 TCP 协议</h3><p>一点概述： - 点对点 - 一个发送方，一个接收方 - 可靠、按序字节流 - 流水线机制 - TCP 拥塞控制和流量控制机制设置字节流 - 传输层实现端到端的流量控制和拥塞控制 - 发送方接收方缓存</p><h4 id="tcp-段结构">5.4.1 TCP 段结构</h4><p><img src="/imgs/CompNet/传输层/TCP段结构.png" alt="TCP段结构" /> - 源端口号和目的端口号各占 16 位 - 用于多路复用/分解 - 序号字段与确认序号字段分别占 32 位 - 对每个应用层数据的每个<strong>字节</strong>进行编号 - 确认序号是<strong>期望</strong>从对方接收数据的字节序号，累计确认 - 首部长度字段占 4 位 - 4 字节为计算单位 - 保留字段占 6 位 - 目前值为 0 - 6 位标志位（字段） - URG = 1，表示紧急指针字段有效 - ACK = 1，标识确认序号字段有效 - PSH = 1，表示尽快将段中数据交付于应用进程 - RST = 1，从新建立 TCP 连接 - SYN = 1，表示 TCP 段是一个建立新连接请求控制段 - FIN = 1，表明请求释放 TCP 连接 - 接收窗口字段占 16 位 - 流量控制 - 校验和字段占 16 位 - 包括 TCP 伪首部、TCP 首部和应用层数据三部分 - 紧急指针字段占 16 位 - URG = 1 时才有效 - 指出紧急数据最后一个字节在数据中的位置 - 选项字段的长度可变 - 最大段长度 MSS - 时间戳 - SACK - 填充字段，长度为 0~3 个字节 - 补位 - 取值全 0</p><h4 id="tcp-可靠数据传输">5.4.2 TCP 可靠数据传输</h4><h4 id="tcp-流量控制">5.4.3 TCP 流量控制</h4><h4 id="tcp-连接控制">5.4.4 TCP 连接控制</h4><p>三次握手： Step 1: client host sends TCP SYN segment to server - specifies initial seq # - no data 得知初始序号 Step 2: server host receives SYN, replies with SYNACK segment - server allocates buffers - specifies server initial seq. # Step 3: client receives SYNACK, replies with ACK segment, which may contain data <img src="/imgs/CompNet/传输层/三次握手.png" alt="三次握手" /> 初始序号会被握手过程给空耗掉</p><p>四次挥手： client closes socket: clientSocket.close(); Step 1: client 向 server 发送 TCP FIN 控制 segment Step 2: server 收到 FIN, 回复 ACK. 关闭连接, 发 送FIN Step 3: client 收到 FIN, 回复 ACK - 进入“等待” ——如果收到 FIN，会重新发送 ACK Step 4: server 收到 ACK. 连接关闭 <img src="/imgs/CompNet/传输层/四次挥手.png" alt="四次挥手" /> 依然会空耗序号</p><h4 id="tcp-拥塞控制">5.4.5 TCP 拥塞控制</h4><p>TCP 慢启动不是跳跃的，其实是连续（？） <span class="math inline">\(rate = \dfrac{CongWin}{RTT} \ Bytes/Sec\)</span></p><h4 id="tcp-性能">5.4.6 TCP 性能</h4><h2 id="总结">总结</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 ex.2 拓扑排序</title>
    <link href="/2022/04/06/Algorithm/%E7%AE%97%E6%B3%95-ex-2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/06/Algorithm/%E7%AE%97%E6%B3%95-ex-2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>依然是做每日一题的时候碰到了，总之记录一下吧！ <a href="https://leetcode-cn.com/problems/minimum-height-trees/">最小高度树</a> 拓扑排序的目的是将所有结点排序，使得排在前面的节点不能依赖于排在后面的节点！</p><h3 id="main">Main</h3><h4 id="basicinfo">BasicInfo</h4><p>展示一个来自 (wikipedia)[https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm] 的代码： <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">L← Empty list that will contain <span class="hljs-keyword">the</span> sorted elements<br>S ← Set <span class="hljs-keyword">of</span> all nodes <span class="hljs-keyword">with</span> no incoming edges<br><span class="hljs-keyword">while</span> S is non-<span class="hljs-literal">empty</span> <span class="hljs-built_in">do</span><br>    remove <span class="hljs-keyword">a</span> node n <span class="hljs-built_in">from</span> S<br>    insert n <span class="hljs-keyword">into</span> L<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> node m <span class="hljs-keyword">with</span> <span class="hljs-keyword">an</span> edge e <span class="hljs-built_in">from</span> n <span class="hljs-built_in">to</span> m <span class="hljs-built_in">do</span><br>        remove edge e <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> graph<br>        <span class="hljs-keyword">if</span> m has no other incoming edges <span class="hljs-keyword">then</span><br>            insert m <span class="hljs-keyword">into</span> S<br><span class="hljs-keyword">if</span> graph has edges <span class="hljs-keyword">then</span><br>    <span class="hljs-literal">return</span> error (graph has <span class="hljs-keyword">at</span> least onecycle)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-literal">return</span> L (<span class="hljs-keyword">a</span> topologically sortedorder)<br></code></pre></td></tr></table></figure></p><h4 id="solution">Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            ans.add(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            adj[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>            adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>            degree[edge[<span class="hljs-number">0</span>]]++;<br>            degree[edge[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainNodes</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">while</span> (remainNodes &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();<br>            remainNodes -= sz;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[curr]) &#123;<br>                    degree[v]--;<br>                    <span class="hljs-keyword">if</span> (degree[v] == <span class="hljs-number">1</span>) &#123;<br>                        queue.offer(v);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            ans.add(queue.poll());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="conclusion">Conclusion</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 ex.1 线段树</title>
    <link href="/2022/04/04/Algorithm/%E7%AE%97%E6%B3%95-ex-1-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/04/04/Algorithm/%E7%AE%97%E6%B3%95-ex-1-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>在写今天的每日一题的时候正好碰到了线段树，总之记录一下吧！ <a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a></p><h3 id="main">Main</h3><h4 id="basicinfo">BasicInfo</h4><p>其实这一个如果什么都不想的话，就很想直接一个模拟操作上去做了，但是如果它频繁的进行一些操作，那么简简单单的实现就很容易超时，所以这里使用<strong>线段树</strong>进行操作！ 首先就迎来了一个问题：什么是线段树？ 线段树是一种常用的用来维护 <strong>区间信息</strong> 的数据结构。 线段树可以在 <span class="math inline">\(O(logN)\)</span> 的时间复杂度内实现以下几种操作： - 单点修改 - 区间修改 - 区间查询（区间求和，求区间最大值，求区间最小值） 可以看出来，单点修改是普通的树就具有的特征，但是这两个区间的操作是线段树的优势地段。 接下来是一些与近世代数有关的性质 线段树维护的信息其实可以认为是满足了（幺）半群的一些特征 - 一个幺半群 <span class="math inline">\(M = (S, \circ, e)\)</span> 所具有的特质： - 封闭性：<span class="math inline">\(\forall x \in S,\ \forall y \in S.\ x \circ y \in S\)</span> - 结合律：<span class="math inline">\(\forall x, y, z \in S, (x \circ y) \circ z = x \circ (y \circ z)\)</span> - 幺元：<span class="math inline">\(\exists e \in S, \forall x \in S\)</span>，如果 <span class="math inline">\(e \circ x = x\)</span>，则 <span class="math inline">\(e\)</span> 为左幺元，或 <span class="math inline">\(x \circ e = x\)</span>，则为右幺元 <del>近世代数真没白学，好啊！</del></p><h4 id="structure">Structure</h4><p>线段树将可分的区间（长度大于 1）的区间划分为左右区间进行递归求解，这样等于是把一个线段划分成了两个线段，就可以视为它的左右孩子节点，这样孩子节点又有孩子节点，就是一棵树了，这样的树就是线段树（树状数组的样子）。 接下来是操作的模板： 建树 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> node)</span> &#123;<br>  <span class="hljs-comment">// 对 [s,t] 区间建立线段树,当前根的编号为 node</span><br>  <span class="hljs-keyword">if</span> (s == e) &#123;<br>    d[p] = a[s];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 移位运算符的优先级小于加减法，所以加上括号</span><br>  <span class="hljs-comment">// 如果写成 (s + e) &gt;&gt; 1 可能会超出 int 范围</span><br>  build(s, m, node * <span class="hljs-number">2</span>), build(m + <span class="hljs-number">1</span>, t, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 递归对左右区间建树</span><br>  d[node] = d[node * <span class="hljs-number">2</span>] + d[(node * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure> 求和 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> node)</span> &#123;<br>    <span class="hljs-comment">// [l, r] 为查询区间，[s, e] 为当前节点包含的区间</span><br>    <span class="hljs-comment">// node 为当前节点</span><br>    <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;<br>        <span class="hljs-keyword">return</span> d[node];<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e - s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (r &lt;= m)<br>        <span class="hljs-keyword">return</span> getSum(l, r, s, m, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; m)<br>        <span class="hljs-keyword">return</span> getSum(l, r, m+<span class="hljs-number">1</span>, e, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> getSum(l, r, s, m, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) + getSum(l, r, m+<span class="hljs-number">1</span>, e, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 修改 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">updage</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == e) &#123;<br>        d[node] = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e - s) &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (idx &lt;= m) &#123;<br>        update(idx, val, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, s, m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        update(idx, val, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, m+<span class="hljs-number">1</span>, e);<br>    &#125;<br>    d[node] = d[node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] + d[node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="solution">Solution</h4><p>看起来和模板有些不同，主要是因为看下标的设置等 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-type">int</span>[] d;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * <span class="hljs-number">4</span>];<br>        build(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        change(index, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> getSum(left, right, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == e) &#123;<br>            d[node] = arr[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e-s) &gt;&gt; <span class="hljs-number">1</span>);<br>        build(s, m, node*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, arr);<br>        build(m+<span class="hljs-number">1</span>, e, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, arr);<br>        d[node] = d[node*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] + d[node*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;<br>            <span class="hljs-keyword">return</span> d[node];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e-s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (r &lt;= m)<br>            <span class="hljs-keyword">return</span> getSum(l, r, s, m, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; m)<br>            <span class="hljs-keyword">return</span> getSum(l, r, m+<span class="hljs-number">1</span>, e, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">return</span> getSum(l, r, s, m, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) + getSum(l, r, m+<span class="hljs-number">1</span>, e, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == e) &#123;<br>            d[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s + ((e-s) &gt;&gt; <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (idx &lt;= m) &#123;<br>            change(idx, val, node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, s, m);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            change(idx, val, node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, m+<span class="hljs-number">1</span>, e);<br>        &#125;<br>        d[node] = d[node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] + d[node * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>线段树大概如此吧，思想还是和树结构关系蛮大的，注意数据结构的理解即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.4 网络层</title>
    <link href="/2022/03/25/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/03/25/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-4-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><ul><li>理解网络层服务</li><li>理解虚电路网络与数据报网络</li><li>掌握路由器体系结构</li><li>掌握 IP 协议<ul><li>IP 数据报</li><li>IP 地址与子网划分</li><li>CIDR 与路由聚合</li></ul></li><li>掌握 DHCP、NAT、ICMP、 ARP 等协议</li><li>掌握典型路由算法和路由协议</li></ul><p>在学习完毕后，你应该能写出这一题： 1.<br />2.<br />3.<br />4.<br />5. 判断子网掩码是否正确，所在生成的子网比实际子网要大</p><h2 id="内容">内容</h2><h3 id="网络层服务">网络层服务</h3><h4 id="概述">概述</h4><ul><li>从发送主机向接收主机传送数据段 (segment)</li><li>发送主机：将数据段封装到数据报 (datagram) 中</li><li>接收主机：向传输层交付数据段 (segment)</li><li>每个主机和路由器都运行网络层协议</li><li>路由器检验所有穿越它的IP数据报的头部域<ul><li>决策如何处理IP数据报 #### 核心功能——转发与路由</li></ul></li><li>转发 (forwarding)：将分组从路由器的输入端口转移到合适的输出端口</li><li>路由 (routing)：确定分组从源到目的经过的路径<ul><li>路由算法 (routing algorithms)<ul><li>路由算法（协议）确定通过网络的端到端路径</li><li>转发表确定在本路由器如何转法分组</li></ul></li></ul></li></ul><h4 id="核心功能连接建立">核心功能——连接建立</h4><ul><li>某些网络的重要功能：<ul><li>ATM, 帧中继, X.25</li></ul></li><li>数据分组传输之前两端主机需要首先建立虚拟/逻辑连接-<ul><li>网络设备（如路由器）参与连接的建立</li></ul></li><li>网络层连接与传输层连接的对比:：<ul><li>网络层连接：两个主机之间（路径上的路由器等网络设备参与其中）</li><li>传输层连接：两个应用进程之间（对中间网络设备透明）</li></ul></li></ul><h4 id="网络层服务模型">网络层服务模型</h4><ul><li><strong>无连接服务</strong> (connection-less service):<ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li><li><strong>数据报网络</strong> (datagram network)</li></ul></li><li><strong>连接服务</strong> (connection service):<ul><li>首先为系列分组的传输确定从源到目的经过的路径（建立连接）</li><li>然后沿该路径（连接）传输系列分组</li><li>系列分组传输路径相同</li><li>传输结束后拆除连接</li><li><strong>虚电路网络</strong> (virtual-circuit network)</li></ul></li></ul><h4 id="拥塞控制">拥塞控制</h4><h5 id="基本介绍">基本介绍</h5><p>拥塞 (Congestion) - 非正式定义：“太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理” - 表现 - 分组丢失（路由器缓存溢出） - 分组延迟过大（在路由器缓存中排队） - 拥塞控制 vs. 流量控制 - A top-10 problem</p><p>接下来是一些拥塞的成因和代价的场景： <img src="/imgs/CompNet/网络层/拥塞场景1.png" alt="1" /> <img src="/imgs/CompNet/网络层/拥塞场景2.png" alt="2-1" /> <img src="/imgs/CompNet/网络层/拥塞场景2-2.png" alt="2-2" /> <img src="/imgs/CompNet/网络层/拥塞场景3.png" alt="3-1" /> <img src="/imgs/CompNet/网络层/拥塞场景3-2.png" alt="3-2" /></p><h5 id="拥塞控制的方法">拥塞控制的方法</h5><ul><li>传输层端到端拥塞控制：<ul><li>网络层不需要显式的提供支持</li><li>端系统通过观察 loss，delay 等网络行为判断是否发生拥塞</li><li>TCP 采取这种方法</li></ul></li><li>网络层（辅助）拥塞控制：<ul><li>路由器向发送方显式地反馈网络拥塞信息</li><li>简单的拥塞指示 (1bit)：SNA, DECbit, TCP/IP ECN, ATM</li><li>指示发送方应该采取何种速率</li></ul></li></ul><p>网络层拥塞控制策略： - 流量感知路由 - 准入控制 - 流量调节 - 抑制分组 - 背压 - 负载脱落</p><p>案例：ATM ABR 拥塞控制 <img src="/imgs/CompNet/网络层/ATMABR-1.png" alt="案例1-1" /> <img src="/imgs/CompNet/网络层/ATMABR-2.png" alt="案例1-2" /></p><h3 id="虚电路网络与数据报网络">虚电路网络与数据报网络</h3><h4 id="连接服务与无连接服务">连接服务与无连接服务</h4><ul><li>数据报 (datagram) 网络与虚电路(virtual-circuit)网络是典型 两类分组交换网络</li><li>数据报网络提供网络层无连接服务</li><li>虚电路网络提供网络层连接服务</li><li>类似于传输层的无连接服务 (UDP) 和面向连接服务 (TCP)，但是网络层服务：<ul><li>主机到主机服务</li><li>网络核心实现 这个简单解释了虚电路和数据报的区别。</li></ul></li></ul><h4 id="虚电路-virtual-circuits">虚电路 (Virtual circuits)</h4><ul><li>通信过程：<ul><li>呼叫建立 (call setup) -&gt; 数据传输 -&gt; 拆除呼叫</li></ul></li><li>每个分组携带虚电路标识 (VC ID)，而不是目的主机地址</li><li>虚电路经过的每个网络设备（如路由器），维护每条经过它的虚电路连接状态</li><li>链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配<ul><li>预分配资源=可预期服务性能</li><li>如 ATM 的电路仿真(CBR) 具体实现： 对于每条虚电路，它包括了</li></ul></li></ul><ol type="1"><li>从源主机到目的主机的一条路径</li><li>虚电路号 (VCID)，沿路每段链路一个编号</li><li>沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路</li></ol><ul><li>沿某条虚电路传输的分组，携带对应虚电路的 VCID，而不是目的地址</li><li>同一条 VC，在每段链路上的 VCID 通常不同<ul><li>路由器转发分组时依据转发表改写/替换虚电路号</li></ul></li></ul><h4 id="数据报">数据报</h4><ul><li>网络层无连接</li><li>每个分组携带目的地址</li><li>路由器根据分组的目的地址转法分组<ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路</li></ul></li></ul><h4 id="最长前缀匹配优先">最长前缀匹配优先</h4><p>在检索转发表时，优先选择与分组目的地址匹配<strong>前缀最长</strong>的入口 (entry)</p><h4 id="数据报网络-vs.-vc-网络">数据报网络 vs. VC 网络</h4><p>Internet (数据报网络) - 计算机之间的数据交换 - “弹性”服务，没有严格时间需求 - 链路类型众多 - 特点、性能各异 - 统一服务困难 - “智能”端系统 (计算机) - 可以自适应、性能控制、差错恢复 - <strong>简化网络，复杂“边缘”</strong></p><p>ATM (VC网络) - 电话网络演化而来 - 核心业务是实时对话： - 严格的时间、可靠性需求 - 需要有保障的服务 - “哑(dumb)”端系统（非智能 ） - 电话机 - 传真机 - <strong>简化“边缘”，复杂网络</strong></p><h3 id="路由器体系结构">路由器体系结构</h3><p>怎么都是英文。。 网络设备对比： |-|集线器 (hub)|交换机 (switche)|网桥 (bridge)|路由器 (router)| |-|-----------|----------------|-------------|--------------| |层次|1|2|2|3| |流量（冲突域）距离|no|yes|yes|yes| |广播域隔离|no|no|no|yes| |即插即用|yes|yes|yes|no| |优化路由|no|no|no|yes| |直通传输 (Cut through)|yes|yes|yes|no|</p><h3 id="ip协议">IP协议</h3><p><img src="/imgs/CompNet/网络层/IPBU.png" alt="IPBU" /> #### IPv4 数据报分组格式 <img src="/imgs/CompNet/网络层/IPv4数据报分组格式.png" alt="分组格式" /> 接下来进行介绍： - <strong>版本号</strong>字段占 4 位，是 IP 协议的版本号 - 且有这样的对应关系：4-&gt; IPv4, 6-&gt;IPv6 - <strong>首部长度</strong>字段占 4 位，是 IP 分组首部长度 - 以 4 字节位单位 - eg: 5 -&gt; IP 首部长度位 20(5*4) 字节 - <strong>服务类型</strong>字段占 8 位，是指示期望获得哪种类型的服务 - 1998 年这个字段改名为区分服务 - 只有在网络提供区分服务 (DiffServ) 时使用 - 一般情况下不使用，通常 IP 分组的该字段（第二字节）的值为 00H - <strong>总长度</strong>字段占 16 位，是 IP 分组的总字节数（首部+数据） - 最大 IP 分组的总长度：65535B - 最小的 IP 分组首部： 20B - IP 分组可以封装的最大数据：65535-20 = 65515B - <strong>标识</strong>字段占 16 位：标识一个 IP 分组 - IP 协议利用一个计数器，每产生IP分组计数器加 1，作为该 IP 分组的标识 - <strong>标志位</strong>字段占 3 位，保留位，DF 位和 MF 位 - DF (Don't Fragment) - MF (More Fragment) - DF=1：禁止分片； DF=0：允许分片 - MF=1：非最后一片； MF=0：最后一片(或未分片) - <strong>片偏移</strong>字段占 13 位，是一个 IP 分组分片封装原IP分组数据的相对偏移量 - 片偏移字段以8字节为单位 - <strong>生存时间(TTL)</strong>字段占 8 位：IP 分组在网络中可以通过的路由器数（或者说是跳步数） - 路由器转发一次分组，TTL - 1 - 如果 TTL = 0，路由器则丢弃该 IP 分组 - <strong>协议</strong>字段占 8 位，是指示 IP 分组封装的是哪个协议的数据包 - 实现复用/分解 - eg. 6 为 TCP，表示封装的为 TCP 段；17 为 UDP，表示封装的是 UDP 数据报 - <strong>首部校验和</strong>字段占 16 位，是实现对 IP 分组首部的差错检测 - 计算校验和时，该字段置为全 0 - 采用反码算数运算求和，和的反码作为首部校验和字段 - 逐跳计算、逐跳校验 - <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong>字段都是占 32 位，分别标识发送分组的源主机/路由器（网络接口）和接受分组的目的主机/路由器（网络接口）的 IP - <strong>选项</strong>字段长度可变，范围位于 1B ~ 40B 之间，携带安全、源选路径、时间戳和路由记录等内容 - 但实际上很少被使用 - <strong>填充</strong>字段占长度可变，范围在 0 ~3B 之间：目的是补齐整个首部，符合 32 位对齐，即保证首部长度是 4 字节的倍数</p><h4 id="ip-分片过程">IP 分片过程</h4><p>假设原 IP 分组总长度为 <span class="math inline">\(L\)</span>，待转发链路的 MTU 为 <span class="math inline">\(M\)</span>，若 <span class="math inline">\(L&gt;M\)</span>，且 DF=0，则可以或需要分片，分片时每个分片的标识复制原 IP 分组的标识。 通常分片时，除最后一个分片，其他分片均分为 MTU 允许的最大分片 一个最大分片可封装的数据应该是 8 的倍数，因此， 一个最大分片可封装的数据为: <span class="math inline">\(d = \lfloor \dfrac{M-20}{8} \rfloor \times 8\)</span> 需要的总片数为： <span class="math inline">\(n=\lceil \dfrac{L-20}{d} \rceil\)</span> 每片的片偏移字段取值为： <span class="math inline">\(F_i = \dfrac{d}{8} \times (i-1),\quad 1 \le i \le n\)</span> 每片的总长度字段为： <span class="math display">\[L_i = \left\{\begin{array}{l} d + 20, \quad \quad \quad 1 \le i \le n \\ L-(n-1)d, \quad i = n \end{array}\right.\]</span> 每片的 MF 标志位为： <span class="math display">\[MF_i = \left\{\begin{array}{l}1 \quad 1 \le i \le n \\ 0 \quad \quad i = n\end{array} \right.\]</span> <img src="/imgs/CompNet/网络层/IP分片使用例.png" alt="使用例" /></p><h4 id="ip-编址">IP 编址</h4><ul><li>IP分组：<ul><li>源地址(SA)-从哪儿来</li><li>目的地址(DA)-到哪儿去</li></ul></li><li>接口(interface): 主机/路由器 与物理链路的连接<ul><li>实现网络层功能</li><li>路由器通常有多个接口</li><li>主机通常只有一个或两个接口 (e.g.，有线的以太网接口，无线的 802.11 接口) <img src="/imgs/CompNet/网络层/有类编址.png" alt="有类编址" /> (ABC可以给用户使用) 特殊 IP 地址</li></ul></li></ul><table><thead><tr class="header"><th>NetID</th><th>HostID</th><th>作为 IP 分组源地址</th><th>作为 IP 分组目的地址</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>全 0</td><td>全 0</td><td>可以</td><td>不可以</td><td>在本网范围内表示本机；在路由表中用于表示默认路由（相当于表示整个 Internet 网络）</td></tr><tr class="even"><td>全 0</td><td>特定值</td><td>不可以</td><td>可以</td><td>表示本网内某个特定主机</td></tr><tr class="odd"><td>全 1</td><td>全 1</td><td>不可以</td><td>可以</td><td>本网广播地址（路由器不转发）</td></tr><tr class="even"><td>特定值</td><td>全 0</td><td>不可以</td><td>不可以</td><td>网络地址，表示一个网络</td></tr><tr class="odd"><td>特定值</td><td>全 0</td><td>不可以</td><td>可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr class="even"><td>127</td><td>非全0或非全1的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试，称为环回地址</td></tr></tbody></table><h4 id="私有-private-ip-地址">私有 (Private) IP 地址</h4><table><thead><tr class="header"><th>Class</th><th>NetIDs</th><th>Blocks</th></tr></thead><tbody><tr class="odd"><td>A</td><td>10</td><td>1</td></tr><tr class="even"><td>B</td><td>172.16 to 172.31</td><td>16</td></tr><tr class="odd"><td>C</td><td>192.168.0 to 192.168.255</td><td>256</td></tr></tbody></table><h4 id="ip-子网-subnets">IP 子网 (Subnets)</h4><p>|--NetID--|--HostID--| - IP 地址： - 网络号 (NetID) ——高位比特 - 主机号 (HostID) ——低位比特 - IP 子网 - IP 地址具有相同网络号的设备接口 - 不跨越路由器（第三以及上层网络设备）可以彼此物理联通的接口</p><p>子网如何划分（区分一个IP子网更小范围网络（子网））？？ |--NetID--|-SubID-|-HostID-| - 网络号 (NetID) ——高位比特 - 子网号 (SubID) ——原网络主机号部分比特 - 主机号 (HostID) ——低位比特</p><h4 id="子网掩码的应用">子网掩码的应用</h4><ul><li>Q: 如何确定是否划分了子网？利用多少位划分子网？</li><li>A: 子网掩码</li></ul><figure><img src="/imgs/CompNet/网络层/子网掩码.png" alt="子网掩码" /><figcaption>子网掩码</figcaption></figure><figure><img src="/imgs/CompNet/网络层/子网划分.png" alt="子网划分" /><figcaption>子网划分</figcaption></figure><figure><img src="/imgs/CompNet/网络层/子网掩码eg.png" alt="eg" /><figcaption>eg</figcaption></figure><p>这里也给出一个 C 类网络划分子网的例子</p><table><thead><tr class="header"><th>子网</th><th>SubID（二进制）</th><th>HostID 取值范围（二进制）</th><th>第 4 八位组取值范围（十进制）</th></tr></thead><tbody><tr class="odd"><td>1#</td><td>000</td><td>00000 thru 11111</td><td>.0 thru .31</td></tr><tr class="even"><td>2#</td><td>001</td><td>00000 thru 11111</td><td>.32 thru .63</td></tr><tr class="odd"><td>3#</td><td>010</td><td>00000 thru 11111</td><td>.64 thru .95</td></tr><tr class="even"><td>4#</td><td>011</td><td>00000 thru 11111</td><td>.96 thru .127</td></tr><tr class="odd"><td>5#</td><td>100</td><td>00000 thru 11111</td><td>.128 thru .159</td></tr><tr class="even"><td>6#</td><td>101</td><td>00000 thru 11111</td><td>.160 thru .191</td></tr><tr class="odd"><td>7#</td><td>110</td><td>00000 thru 11111</td><td>.192 thru .223</td></tr><tr class="even"><td>8#</td><td>111</td><td>00000 thru 11111</td><td>.224 thru .255</td></tr></tbody></table><h4 id="路由聚合">路由聚合</h4><p>简化网络 无类域间路由(CIDR: Classless InterDomain Routing) - 提高IPv4 地址空间分配效率 - 提高路由效率 - 将多个子网聚合为一个较大的子网 - 构造超网（supernetting）</p><h4 id="ipv6">IPv6</h4><p>提出的动机： - 核心：32 位 IPv4 地址空间不够用了 - 其他：改进首部格式 - 快速处理/转发数据报 - 支持 QoS</p><p>数据报格式： - 固定长度的 40 字节基本首部（确定） - 不允许分片</p><p>|基本头|若干个扩展首部|数据部分(e.g. TCP)| |-----|&lt;----------载荷----------------&gt;|</p><p>tupian - <strong>优先级 (priority)</strong>，标识数据报的优先级 - <strong>流标签</strong>， - <strong>下一个首部</strong></p><ul><li>源地址和目的地址都比 IPv4 宽，<ul><li><del>大到地球上每一粒沙子都可以分配地址</del></li></ul></li><li>IPv6 没有校验和，减少每跳时间（原本校验和就是看首部有无错误，太低效）</li></ul><p>地址表示形式 - 一般形式 - 1080:0:FF:0:8:800:200C:417A - 压缩形式（十六进制冒号压缩） - 甚至可以连续压缩连续的 0 - FF01:0:0:0:0:0:0:43 - 压缩→FF01::43 - IPv4-嵌入形式: - 0:0:0:0:0:FFFF:13.1.68.3 或 ::FFFF:13.1.68.3 - 地址前缀 - 2002:43c:476b::/48 (注: IPv6不再使用掩码!) - URLs: - http://[3FFE::1:800:200C:417A]:8000</p><p>数据报的目的地址可以是一下三种基本类型的地址： 1. 单播：点对点。 2. 组播：一对多，发送到<strong>一组的每台</strong>。 3. 任意播：目的是一组，但是只给<strong>一组中的一台</strong>。</p><blockquote><p>【例】某网络拓扑如下图所示，路由器 R1 通过接口 E1、E2 分别连接局域网1、局域网2，通过接口 L0 连接路由器 R2，并通过路由器 R2 连接域名服务器与互联网。R1 的 L0 接口的 IP 地址是 202.118.2.1；R2 的 L0 接口的 IP 地址是 202.118.2.2，L1 接口的 IP 地址是 130.11.120.1，E0 接口的 IP 地址是 202.118.3.1；域名服务器的 IP 地址是 202.118.3.2。 <img src="/imgs/CompNet/网络层/网络层例题图.png" alt="例题图" /> R1和R2的路由表结构为：|目的网络IP地址| 子网掩码| 下一跳IP地址| 接口| （1）将 IP 地址空间 202.118.1.0/24 划分为 2 个子网，分别分配给局域网1、局域网2，每个局域网需分配的 IP 地址数不少于120个。请给出子网划分结果，说明理由或给出必要的计算过程。 解：把 IP 地址空间 202.118.1.0/24 划分为 2 个等长的子网。划分结果： 子网1：子网地址为 202.118.1.0，子网掩码为 255.255.255.128 （或子网1：202.118.1.0/25） 子网2：子网地址为 202.118.1.128，子网掩码为 255.255.255.128 （或子网2：202.118.1.128/25） 地址分配方案：子网 1 分配给局域网 1，子网 2 分配给局域网 2。 （2）请给出 R1 的路由表， 使其明确包括到局域网1 的路由、局域网2的路由、 域名服务器的主机路由和互联网的路由。 解： 若子网 1 分配给局域网 1，子网 2 分配给局域网 2（2）R1的路由表如下： |目的网络 IP 地址|子网掩码|下一跳IP地址|接口| |-|-|-|-| |202.118.1.0|255.255.255.128|-|E1| |202.118.1.128|255.255.255.128|-|E1| |202.118.3.2|255.255.255.255|202.118.2.2|L0| |0.0.0.0|0.0.0.0|202.118.2.2|L0| （3）请采用路由聚合技术，给出 R2 到局域网 1 和局域网 2 的路由。 解：R2 的路由表中，到局域网 1 和局域网 2 的路由表项如下： |目的网络 IP 地址|子网掩码|下一跳IP地址|接口| |-|-|-|-| |202.118.1.0|255.255.255.0|202.118.2.1|L0|</p></blockquote><h3 id="ip相关协议">IP相关协议</h3><h4 id="互联网控制报文协议-icmp">互联网控制报文协议 (ICMP)</h4><p>(ping) - 互联网控制报文协议 ICMP (Internet Control Message Protocol) - 支持主机或路由器： - 差错(或异常)报告 - 网络探询 - 两类 ICMP 报文: - 差错报告报文(5种) - 目的不可达 - 源抑制 (Source Quench) - 比如拥塞 - 超时/超期 - 参数问题 - 重定向 (Redirect) - 网络探询报文(2组) - 回声 (Echo) 请求与应答报文 (Reply) (eg.ping) - 时间戳请求与应答报文</p><h4 id="动态主机配置协议-dhcp">动态主机配置协议 (DHCP)</h4><p>如何获得 IP 地址？ 动态主机配置协议-DHCP: Dynamic Host Configuration Protocol - 从服务器动态获取： - IP 地址 - 子网掩码 - 默认网关地址 - DNS 服务器名称与 IP 地址 - “即插即用” - 允许地址重用 - 支持在用地址续租 - 支持移动用户加入网络</p><ul><li>主机广播 "DHCP discover"（发现报文）</li><li>DHCP服务器利用 "DHCP offer" （提供报文）进行响应</li><li>主机请求IP地址："DHCP request" （请求报文）</li><li><p>DHCP服务器分配IP地址: "DHCP ack" （确认报文） <img src="/imgs/CompNet/网络层/DHCP实例.png" alt="DHCP工作过程示例" /></p></li><li>DHCP 协议在应用层实现</li><li>DHCP 报文封装到 UDP 数据报中</li><li>IP 广播</li><li>链路层广播 (e.g. 以太网广播)</li><li>DHCP 服务器构造 ACK 报文<ul><li>包括分配给客户的 IP 地址、子网掩码、默认网关、DNS 服务器地址</li></ul></li></ul><h4 id="网络地址转换-nat">网络地址转换 (NAT)</h4><p>NAT (Network Address Translation)，处于以下原因： - 只需/能从 ISP 申请一个 IP 地址 - IPv4 地址耗尽 - 本地网络设备 IP 地址的变更，无需通告外界网络 - 变更 ISP 时，无需修改内部网络设备 IP 地址 - 内部网络设备对外界网络不可见，即不可直接寻址（安全） 所以，为了节省 IP 地址的消耗，也隐藏网络内部结构就可以通过 NAT 完成。 为了网络安全，划分了部分 IP 地址为私有地址，这些地址只用于 LAN 而不用于 WAN。 私有地址网段有：</p><table><thead><tr class="header"><th>类别</th><th>网段数目</th><th>范围</th></tr></thead><tbody><tr class="odd"><td>A</td><td>1</td><td><strong>10</strong>.0.0.0 ~ <strong>10</strong>.255.255.255</td></tr><tr class="even"><td>B</td><td>16</td><td><strong>172.16</strong>.0.0 ~ <strong>172.31</strong>.255.255</td></tr><tr class="odd"><td>C</td><td>256</td><td><strong>192.168.0</strong>.0 ~ <strong>192.168.255</strong>.255</td></tr></tbody></table><p>C 类的 192.168.xxx.xxx 是不是很熟悉呢~ 实现： - 替换 - 利用(NAT IP地址,新端口号)替换每个外出IP数据报的(源IP地址, 源端口号) - 记录 - 将每对(NAT IP地址, 新端口号) 与(源IP地址, 源端口号)的替换信息存储到 NAT 转换表中 - 替换 - 根据 NAT 转换表，利用(源IP地址, 源端口号)替换每个进入内网 IP 数据报的(目的 IP 地址,目的端口号)，即 (NAT IP地址, 新端口号)</p><ul><li>16-bit 端口号字段：<ul><li>可以同时支持 60,000 多并行连接！</li></ul></li><li>NAT 主要争议：<ul><li>路由器应该只处理第3层功能</li><li>违背端到端通信原则<ul><li>应用开发者必须考虑到NAT的存在，e.g., P2P 应用</li></ul></li><li>地址短缺问题应该由 IPv6 来解决</li></ul></li></ul><p>NAT 穿透： 1. 静态配置 NAT - 特定端口的连接请求转发给服务器，e.g., (138.76.29.7, 2500) 总是转发给 (10.0.0.1, 25000) 2. 利用 UPnP (Universal Plug and Play) 互联网网关设备协 (IGD-Internet Gateway Device) 自动配置 - 学习到 NAT 公共 IP 地址 (138.76.29.7) - 在 NAT 转换表中，增删端口映射 3. 中继（如 Skype） - NAT内部的客户与中继服务器建立连接 - 外部客户也与中继服务器建立连接 - 中继服务器桥接两个连接的分组</p><blockquote>某校园网有两个局域网，通过路由器 R1、R2和R3 互联后接入 Internet，S1 和 S2 为以太网交换机。局域网采用静态 IP 地址配置。 <img src="/imgs/CompNet/网络层/NAT例.png" alt="例2图" /> （1）为使 H2 和 H3 能 够访问 Web 服务器 （使用默认端口号）， 需要进行什么配置？ 静态配置 R2 的 NAT<table><tr><th colspan="2" align="center">外网</th><th colspan="2" align="center">内网</th></tr><tr><td>IP 地址</td><td>端口号</td><td>IP 地址</td><td>端口号</td><tr><tr><td>203.10.2.2</td><td>80</td><td>192.168.1.2</td><td>80</td><tr></table><p>（2）若 H2 主动访问 Web 服务器时，将 HTTP 请求报文 封装到 IP 数据报 P 中发送，则 H2 发送的 P 的源 IP 地址和目的 IP 地址分别是什么？经过 R3 转发后，P 的源 IP 地址和目的 IP 地址分别是什么？经过 R2 转发后，P 的源 IP 地址和目的 IP 地址分别是什么？</br> 解： H2 发送的 P 的源 IP 地址和目的 IP 地址分别是：192.168.1.2 和 203.10.2.2；R3 转发后，P 的源 IP 地址和目的 IP 地址分别是：203.10.2.6 和 203.10.2.2；R2 转发后，P 的源 IP 地址和目的 IP 地址分别是：203.10.2.6 和 192.168.1.2。</p></blockquote><h4 id="arp-地址解析协议">ARP: 地址解析协议</h4><p>已知 IP 如何确定 MAC 地址？ 地址解析协议！ 每台主机上有一个 ARP 缓存，用来存放本局域网上各主机和路由器的 IP 地址到 MAC 地址的映射表，即 ARP 表。 同一局域网内： - A 想要给同一局域网内的B发送 数据报 - B 的 MAC 地址不在 A 的 ARP 表中. - A 广播 ARP 查询分组，其中包 含B的IP地址 - 目的 MAC 地址 = FF-FF-FF-FFFF-FF - LAN 中所有结点都会接收 ARP 查询 - B 接收 ARP 查询分组，IP 地址匹配成功，向 A 应答 B 的MAC 地址 - 利用单播帧向A发送应答 - A 在其 ARP 表中，缓存 B 的 IP-MAC 地址对，直至超时 - 超时后，再次刷新 - ARP 是“即插即用”协议： - 结点自主创建 ARP 表， 无需干预</p><p>一个 LAN 到另一个 LAN： - A 构造 IP 数据报，源 IP 地址是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址 - A 构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是 <strong>R接口的 MAC 地址</strong>，封装 A 到 B 的 IP 数据报。 即目的 MAC 地址看默认网关，目的 IP 地址直接看真的 IP 地址。</p><h3 id="路由算法">路由算法</h3><p>路由算法（协议）确定去往目的网络的最佳路径 关键问题：源到目的（如 u 到 z）的最小费用路径是什么？ 路由算法：寻找最小费用路径的算法</p><h4 id="链路状态路由算法">链路状态路由算法</h4><p>Dijkstra，具体实现太经典啦，不在这里赘述。 - 所有结点（路由器）掌握网络拓 扑和链路费用 - 通过“链路状态广播” - 所有结点拥有相同信息 - 计算从一个结点（“源”）到达 所有其他结点的最短路径 - 获得该结点的转发表 - 迭代：k 次迭代后，得到到达 k 个目的结点的最短路径 - 每次迭代:需要检测所有不在集合<span class="math inline">\(N^{&#39;}\)</span>中的结点 w - <span class="math inline">\(n(n+1)/2\)</span>次比较: <span class="math inline">\(O(n^2)\)</span> - 更高效的实现: <span class="math inline">\(O(nlogn)\)</span></p><h4 id="距离向量-distance-vector-路由算法">距离向量 (Distance Vector) 路由算法</h4><p>Bellman-Ford 方程（动态规划） 重点：结点获得最短路径的下一跳, 该信息用于转发表中！ 核心思想: - 每个结点不定时地将其自身的 DV 估计发送给其邻居 - 当x接收到邻居的新的 DV 估计时，即依据 B-F 更新其自身的距离向量估计： <span class="math inline">\(D_x(y) \leftarrow min_v\{c(x,v) + D_v(y)\} \ for \ each \ node \ y \ \in \ N\)</span> - <span class="math inline">\(D_x(y)\)</span> 将最终收敛于实际的最小费用 <span class="math inline">\(d_x(y)\)</span></p><h4 id="层次路由">层次路由</h4><p>将任意规模网络抽象为一个图计算路由——过于理想化 - 标识所有路由器 - “扁平”网络 ——在实际网络（尤其是大规模网络）中，不可行！ <img src="/imgs/CompNet/网络层/例3图.png" alt="例" /> 根据距离矢量路由算法，收敛状态下各路由器的距离矢量为：</p><table><thead><tr class="header"><th>目的网络</th><th>R1</th><th>R2</th><th>R3</th></tr></thead><tbody><tr class="odd"><td>192.168.1.0/24</td><td>1</td><td>2</td><td>3</td></tr><tr class="even"><td>192.168.2.0/23</td><td>3</td><td>2</td><td>1</td></tr></tbody></table><p>当 R3 检测到子网 192.168.2.0/23 不可到达后，各路由器的距离矢量为：</p><table><thead><tr class="header"><th>目的网络</th><th>R1</th><th>R2</th><th>R3</th></tr></thead><tbody><tr class="odd"><td>192.168.1.0/24</td><td>1</td><td>2</td><td>3</td></tr><tr class="even"><td>192.168.2.0/23</td><td>3</td><td>2</td><td><strong>3</strong></td></tr></tbody></table><p>交换一次距离矢量后，各路由器的距离矢量为：</p><table><thead><tr class="header"><th>目的网络</th><th>R1</th><th>R2</th><th>R3</th></tr></thead><tbody><tr class="odd"><td>192.168.1.0/24</td><td>1</td><td>2</td><td>3</td></tr><tr class="even"><td>192.168.2.0/23</td><td>3</td><td><strong>4</strong></td><td>3</td></tr></tbody></table><p>第二次交换距离矢量后，各路由器的距离矢量为：</p><table><thead><tr class="header"><th>目的网络</th><th>R1</th><th>R2</th><th>R3</th></tr></thead><tbody><tr class="odd"><td>192.168.1.0/24</td><td>1</td><td>2</td><td>3</td></tr><tr class="even"><td>192.168.2.0/23</td><td><strong>5</strong></td><td>4</td><td><strong>5</strong></td></tr></tbody></table><p>R1 所维护的距离矢量包括自身的距离矢量以及邻居 R2 最新交换过来的距离矢量。</p><h3 id="路由协议">路由协议</h3><p>以 Internet 网络为例 - 采用层次路由 - AS 内部路由协议——内部网关协议 (IGP) - 最常见的 AS - 路由信息：RIP - 开放最短路径优先：OSRF - 内部网关路由协议：IGRP - Cisco 私有</p><h4 id="rip">RIP</h4><p>1982 年随 BSD-UNIX 发布</p><p>距离路由度量算法： - 距离度量：跳步数 hop ，每条链路一个跳步 - 每隔 30s，邻居之间交换一次 DV，成为通告 - 每次通告，最多 25 个目的子网 (IP addr)</p><p>通过下一跳信息实现毒性逆转</p><p>180s 未收到通告，则邻居/链路失效 - 经过该邻居的路由不可用 - 重新计算路由 - 向邻居发送新的通告 - 邻居再依次向外发送通告（如果转发表改变） - 链路失效信息能否快速传播到全网？ - 可能发生无穷计数问题 - 毒性逆转技术用于预防乒乓 (ping-pong) 环路 (另外：无穷大距离 = 16 hops)</p><p>实现： - RIP 路由表是利用一个称作route-d (daemon) 的应用层进程进行管理 - 应用进程实现 - 通告报文周期性地通过UDP数据报发送 &gt; 例题 某自治系统采用 RIP 协议 ，若该自治系统内的路由器 R1 收到其邻居路由器 R2 的距离矢量，距离矢量中包含信息 “ &lt; net1，16 &gt;” ，则能得出的结论是 ( ) A.R2 可以经过 R1 到达 net1，跳数为 17 B.R2 可以到达 net1，跳数为 16 C.R1 可以经过 R2 到达 net1，跳数为 17 D.R1 不能经过 R2 到达 net1 </br> 超过 15 跳，选 D</p><h4 id="osrf">OSRF</h4><p>RIP 不具备的优点： - 安全 (security): 所有 OSPF 报文可以被认证 (预防恶意入侵) - 允许使用多条相同费用的路径 (RIP 只能选一条) - 对于每条链路，可以针对不同的 TOS 设置多个不同的费用 度量 (e.g. 卫星链路可以针对“尽力” (best effort) ToS 设置“低”费用；针对实时 ToS 设置“高”费用) - 集成单播路由与多播路由: - 多播 OSPF 协议 (MOSPF) 与 OSPF 利用相同的网络拓扑数据 - OSPF 支持对大规模 AS 分层 (hierarchical)</p><h4 id="bgp">BGP</h4><ul><li>边界网关协议 BGP (Border Gateway Protocol): 事实上的 标准域间路由协议<ul><li>将 Internet “粘合”为一个整体的关键</li></ul></li><li>BGP为每个AS提供了一种手段:<ul><li>eBGP: 从邻居 AS 获取子网可达性信息.</li><li>iBGP: 向所有 AS 内部路由器传播子网可达性信息.</li><li>基于可达性信息与策略，确定到达其他网络的 “好” 路径.</li></ul></li><li>容许子网向 Internet 其余部分通告它的存在：“我在这儿！” BGP 路由选择策略</li></ul><h4 id="三种协议比较">三种协议比较</h4><table><thead><tr class="header"><th>协议</th><th>RIP</th><th>OSPF</th><th>BGP</th></tr></thead><tbody><tr class="odd"><td>类型</td><td>内部</td><td>内部</td><td>外部</td></tr><tr class="even"><td>路由算法</td><td>距离-向量</td><td>链路状态</td><td>路径-向量</td></tr><tr class="odd"><td>传递协议</td><td>UDP</td><td>IP</td><td>TCP</td></tr><tr class="even"><td>路径选择</td><td>跳数最少</td><td>代价最低</td><td>较好，非最佳</td></tr><tr class="odd"><td>交换结点</td><td>本结点相邻</td><td>网络中所有路由器</td><td>本结点相邻</td></tr><tr class="even"><td>交换内容</td><td>自己的路由表</td><td>相邻的所有路由器的链路状态</td><td>首次：整个路由表</br>非首次：有变化的部分</td></tr></tbody></table><h2 id="总结">总结</h2><ul><li>网络层服务</li><li>虚电路网络与数据报网络</li><li>路由器体系结构</li><li>IP 协议<ul><li>IP 数据报</li><li>IP 地址与子网划分</li><li>CIDR 与路由聚合</li><li>IPv6</li></ul></li><li>ICMP、DHCP、NAT、ARP 等协议</li><li>典型路由算法<ul><li>链路状态路由算法</li><li>距离向量路由算法</li><li>层次路由</li></ul></li><li>典型路由协议<ul><li>RIP</li><li>OSPF</li><li>BGP</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.3 数据链路层与局域网</title>
    <link href="/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <url>/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出差错的物理连接改造为逻辑上无差错的数据链路，使其对网络层能够表现为一条无差错的链路。 在这一章主要学习： - 理解数据链路层主要服务 - 理解链路层寻址及其特点 - 掌握差错编码原理及典型编码 - 掌握可靠数据传输基本原理及协议、信道利用率的计算 - 掌握多路访问控制协议特点 - 掌握以太网技术、交换机工作原理、VLAN 技术等 - 理解PPP协议 - 了解链路虚拟化概念及原理</p><h2 id="内容">内容</h2><h3 id="数据链路层服务">数据链路层服务</h3><h4 id="基本介绍">基本介绍</h4><p>数据链路层位于网络层 (AL) 和物理层 (PHL) 之间，它向上对网络层提供<strong>明确 (well-defined) 的服务接口</strong>，向下利用物理层提供的位流服务。 - 负责<strong>结点-结点 (node-to-node)</strong> 数据传输 - <strong>组帧 (Framing)</strong> - <strong>物理寻址 (Physical addressing)</strong> - <strong>流量控制 (Flow control)</strong> - <strong>差错控制 (Error control)</strong> - <strong>访问控制 (Access control)</strong></p><h4 id="术语">术语</h4><ul><li>结点 (nodes)：主机、路由器、交换机</li><li>链路 (links)：连接相邻结点的通信信道<ul><li>有线链路 (wired links)</li><li>无线链路 (wireless links)</li><li>局域网 (LANs)</li></ul></li><li>帧 (frame)：链路层（第二层）数据分组，封装网络层数据报 <strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</li></ul><h4 id="链路层服务">链路层服务</h4><p>链路层的服务主要是组帧，即 framing - 封装网络层数据报构成数据帧 - 帧同步：从物理层接收的比特流中准确区分出一帧的开始与结束 - 字节计数法 (Byte count) - 但是会在某个计数字节出错后导致错误（失去了帧边界划分的依据） - 带字节填充的定界符法 (Flag bytes with byte stuffing) - 定界符 (FLAG)：一个特殊的字节，比如 01111110，即 0x7E，用于区分前后两个不同的帧 - 一个帧在这里的结构大概是 FLAG + 头标 + 有效载荷 + 尾标 + FLAG - 但是如果有效载荷部分包含与定界符相同的字节也会出问题！ - 所以需要使得信息为中出现的特殊字符不被认为是帧的首尾定界符，需要在特殊字符中填充转义字符。 - 带比特填充的定界符法 (Flag bits with bit stuffing) - 定界符：如两个 0 比特之间，连续 6 个 1 比特，即 01111110，0x7E - 但是也会有有效载荷部分包含与定界符相同的为组合诶… - 于是发送方的数据链路层在信息为中遇到连续 5 个连续的“1”时，自动插入一个“0”，接收方只需要做逆操作就可以了！ - 0 比特填充法很容易通过硬件实现，性能优于字符填充 - 物理层编码违例 (Physical layer coding violations) - 核心思想：定界符为不会在数据部分出现的码字。 - 4B/5B 编码方案：未使用的码字 - 前导码：存在很长的前导码 (preamble) - 例如：传统以太网、802.11 - 曼彻斯特编码/差分曼彻斯特编码：比特周期<strong>中间信号无跳变</strong> - （将比特 “1” 编码成为“高-低”电平对，将比特“0”编码成为“低-高”电平对，“高-高”、“低-低”电平对在数据比特中是违规的） - 例如：802.5 令牌环网</p><h4 id="链路层的具体实现">链路层的具体实现</h4><ul><li>每个主机或路由器接口</li><li>链路层即在“适配器”（网络接口卡-NIC）中实现</li><li>或者在一个芯片上实现以下内容<ul><li>以太网网卡、802.11 网卡； 以太网芯片组</li><li>实现链路层和物理层</li></ul></li><li>连接主机的系统总线</li><li>由硬件、软件与固件组成</li></ul><h4 id="网卡间通信">网卡间通信</h4><p>发送端： - 将数据报封装成帧 - 增加差错检测比特，实现可靠数据传输和流量控制等</p><p>接收端： - 检测差错，实现可靠数据传输和流量控制等 - 提取数据报，交付上层协议实体</p><h3 id="差错检测与纠正">差错检测与纠正</h3><h4 id="差错编码基本原理">差错编码基本原理</h4><p><span class="math inline">\(D \rightarrow DR\)</span> 其中 <span class="math inline">\(R\)</span> 为差错检测与纠正比特（冗余比特） <span class="math inline">\(输入 \rightarrow D \rightarrow R = f(D) \rightarrow |D\quad |R| \rightarrow |\quad 信道 \quad | \rightarrow |D^{&#39;} \quad | R^{&#39;} | \rightarrow R^{&#39;} = f(D^{&#39;}) ? \ 是则输出，否则错误\)</span> 注：差错编码<strong>不能保证 100% 可靠</strong></p><h4 id="差错编码的检错能力">差错编码的检错能力</h4><p>差错编码可以分为<strong>检错码</strong>和<strong>纠错码</strong>。 这里引入一个概念——汉明距离 (Hamming distance)，顾名思义，应该与汉明码有关！ 汉明距离即为两个码字之间对应位不同的数目。 对于检错码，如果编码集的汉明距离 <span class="math inline">\(d_s = r+1\)</span>，则该差错编码可以检测 <span class="math inline">\(r\)</span> 位差错。 - 例如，编码集 {0000, 0101, 1010, 1111} 的汉明距离 <span class="math inline">\(d_s = 2\)</span>，可以 100% 检测 1 比特差错。 对于纠错码，如果编码集的汉明距离 <span class="math inline">\(d_s = 2r+1\)</span>，则该纠错码可以纠正 <span class="math inline">\(r\)</span> 位差错 - 例如，编码集 {000000, 010101, 101010, 111111} 的汉明距离 <span class="math inline">\(d_s = 3\)</span> 可以纠正 1 比特差错，如 100010 纠正为 101010</p><h4 id="奇偶校验码">奇偶校验码</h4><p>1 比特校验位： - 检测奇数位差错</p><p>二维奇偶校验： - 检测奇数位差错、部分偶数位差错 - 纠正同一行/列的奇数位错</p><h4 id="internet-校验和-checksum">Internet 校验和 (Checksum)</h4><p>发送端： - 将“数据”（校验内容）划分为 16 位的二进制“整熟”序列。 - 求和 (sum)：补码求和（最高位进位的“1”，返回最低位继续加） - 校验和 (Checksum)：sum 的反码。 - 放入分组 (UDP, TCP, IP) 的校验和字段。</p><p>接收端： - 与发送端相同的算法计算 - 计算得到的 "checksum" - 为 16 位全 0（或 sum 为 16 位全 1）——无错 - 否则即为出错</p><h4 id="循环冗余校验码-crc">循环冗余校验码 (CRC)</h4><p>这个是一个检错能力更强的差错编码，它将数据比特 <span class="math inline">\(D\)</span> 视为一个二进制数，选择一个 <span class="math inline">\(r+1\)</span> 位的比特模式（生成比特模式），<span class="math inline">\(G\)</span>。 （上面那句话的意思其实就是：<span class="math inline">\(G\)</span> 其实有 <span class="math inline">\(r\)</span> 位，<span class="math inline">\(D\)</span> 在其尾部添加 <span class="math inline">\(r-1\)</span> 位 <span class="math inline">\(0\)</span>） 目标是：选择 <span class="math inline">\(r\)</span> 位的 CRC 比特，其中 <span class="math inline">\(R\)</span> 满足： - <span class="math inline">\(&lt;D, R&gt;\)</span>刚好可以被 <span class="math inline">\(G\)</span> 整除（模 2 除法，这一步中做的是异或运算而不是常规的借位除法运算） - 接收端检错：利用 <span class="math inline">\(G\)</span> 除 <span class="math inline">\(&lt;D, R&gt;\)</span>，余式全 0 则没有错否则即为有错 - 可以检测所有突发长度小于 <span class="math inline">\(r+1\)</span> 位差错 广泛应用于实际网络（以太网，802.11 WiFi，ATM）</p><h4 id="crc-举例">CRC 举例</h4><figure><img src="/imgs/CompNet/链路层/CRC举例.png" alt="CRC 举例" /><figcaption>CRC 举例</figcaption></figure><h4 id="差错纠正">差错纠正</h4><ul><li>前向纠错<ul><li>纠错码</li></ul></li><li>检错重发<ul><li>停-等协议</li><li>滑动窗口协议</li></ul></li><li>反馈校验</li><li>检错丢弃</li><li>……</li></ul><h3 id="可靠数据传输">可靠数据传输</h3><p><del>这里会讲到好多协议啊</del> #### 一些概念 - 什么是可靠？ - 不错、不丢，不乱、不多 - 可靠数据传输协议 - 可靠数据传输对应用层、传输层、链路层都很重要 - 网络Top-10问题 - 信道的不可靠特性 决定了可靠数据传输协议(rdt)的复杂性</p><p>Rdt1.0, Rdt2.0, Rdt2.1, Rdt2.2, Rdt3.0</p><h4 id="流水线协议">流水线协议</h4><p>目的是为了提高资源利用率，就是流水线思想！ 允许发送方在收到 ACK 之前连续发送多个分组 - 更大的序列号范围 - 发送方和/或接收方需要更大的存储空间以缓存分组</p><h4 id="滑动窗口协议">滑动窗口协议</h4><!-- 留点内容读读书再填 --><ul><li>窗口<ul><li>允许使用的序列号范围</li><li>窗口尺寸为 N：最多有 N 个等待确认的消息</li></ul></li><li>滑动窗口<ul><li>随着协议的运行，窗口在序列号空间内向前滑动</li></ul></li><li>滑动窗口协议：GBN, SR</li><li>从概念上看：停止-等待协议、后退 N 帧协议和选择重传协议只是发送、接收窗口的大小有区别：</li></ul><table><thead><tr class="header"><th>协议</th><th>发送窗口大小</th><th>接收窗口大小</th></tr></thead><tbody><tr class="odd"><td>停止-等待</td><td>1</td><td>1</td></tr><tr class="even"><td>后退 N 帧</td><td>&gt;1</td><td>1</td></tr><tr class="odd"><td>选择重传</td><td>&gt;1</td><td>&gt;1</td></tr></tbody></table><ul><li>滑动窗口协议的信道利用率: <span class="math inline">\(U = \dfrac{W_s \times t_{Seg}}{t_{Seg} + RTT + t_{ACK}} \Rightarrow U = \dfrac{W_s \times L/R}{L/R + 2dp + L^{&#39;} / R} \Rightarrow U = \dfrac{W_s \times L}{L + 2dpR + L^{&#39;}}\)</span></li><li>数据链路层的滑动窗口协议中，窗口大小在传输过程是固定的（与传输层的滑动窗口区别）</li></ul><p>滑动窗口和 ARQ - ARQ 协议分等停 ARQ 协议和连续 ARQ 协议，连续 ARQ 协议了采用滑动窗口方法，又分为后退 N 步协议和选择重传协议</p><h4 id="go-back-n-gbn-协议">Go-Back-N (GBN) 协议</h4><h5 id="简介">简介</h5><p>在 GBN 中，发送方不需要等收到上一帧的 ACK 后才能开始发送下一帧，它可以直接连续进行帧发送。 - 接收方检测出失序的信息帧后，要求发送方重发<strong>最后一个正确接收的信息帧之后</strong>的所有未被确认的帧 - 发送方发送了 N 个帧后，若发现 N 个帧的前一个帧在计时器超时后仍未返回确认消息，则判定为出错或丢失，此时发送方重传该出错帧及随后的 N 个帧。 - 接收方只允许顺序接受帧。 ##### 描述 - 分组头部包含 k-bit 序列号 - 窗口尺寸为 N，最多允许 N 个分组未确认 - ACK(n): 确认的序列号 n 的分组均已被正确接收 - 累计确认 - 可能收到重复 ACK - 为空中的分组设置计时器 (timer) - 超时 Timeout(n) 事件：重传序列号大于等于 n，还未收到 ACK 的所有分组。</p><!-- ##### 发送方##### 接收方扩展 FSM --><h5 id="示例">示例</h5><p>Q: 数据链路层采用后退 N 帧协议，发送方已经发送了编号为 0~7 的帧。当计时器超时时，若发送方只收到 0、2、3 号帧的确认，则发送方需要重发的帧数是多少？分别是那几个帧？ A: 根据 GBN 协议工作原理，GBN 协议的确认是累积确认，所以此时发送端需要重发的帧数是 4 个，依次分别是 4、5、 6、7 号帧。</p><h4 id="selective-repeat-sr-协议">Selective Repeat (SR) 协议</h4><h5 id="基本信息">基本信息</h5><p>为了进一步提高信道利用率，可以考虑只对出现差错的数据帧或者是超时的数据帧，但是为了能够容纳下发送序号不连续且仍处在接收窗口中的数据帧，需要增大接收窗口。 为了保证接收方向前移动窗口后，新旧窗口的序号没有重叠的部分，需要满足如下条件： <span class="math inline">\(W_R + W_T \le 2^n\)</span></p><ul><li>接收方对每个分组单独进行确认<ul><li>设置缓存机制，缓存乱序到达的分组</li></ul></li><li>发送方只重传那些没收到ACK的分组<ul><li>为每个分组设置定时器</li></ul></li><li>发送方窗口<ul><li>N个连续的序列号</li><li>限制已发送且未确认的分组数</li></ul></li><li>接收窗口 -<ul><li>可以接收的无差错到达的分组序号</li></ul></li></ul><h3 id="多路访问控制协议">多路访问控制协议</h3><h4 id="总述">总述</h4><p>多路访问控制 MAC 也是介质访问控制，它需要完成的任务是——使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。 假设一些结点共享广播信道，他们互相发生通信，如果不加控制，那么结点间的通信可能会因为互相干扰而失败，而介质访问的任务就是，采取措施，保证不会因为发生干扰而失败。 常见的介质访问控制方法有： - 信道划分 (channel partitioning) - 多路复用技术 - 在一条介质上同时携带多个传输信号来提高传输系统利用率 - 把多个物理信道组合在一条物理信道上 - TDMA, FDMA, CDMA, WDMA... - 随机访问 (random access) - 信道不划分，允许冲突 - 采用冲突“恢复”机制 - 轮询访问 （轮转 “taking turns”） - 结点轮流使用信道 其中信道划分是静态方法，随机和轮询是动态方法。</p><ul><li>多路访问控制协议 (multiple access control protocol)<ul><li>采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据</li><li>必须基于信道本身，通信信道共享协调信息！<ul><li>无带外信道用于协调</li></ul></li></ul></li></ul><h4 id="信道划分">信道划分</h4><h5 id="tdma">TDMA</h5><p>TDMA: Time Division Multiple Access - 时分多路复用 将物理信道按时间分成若干的时间片，轮流地分配给多个信号使用。 - “周期性”接入信道 - 每个站点在每个周期，占用固定长度的时隙 (e.g.长度 = 分组传输时间) - 未用时隙空闲 (idle)</p><h5 id="fdma">FDMA</h5><p>FDMA: Frequency Division Multiple Access - 频分多路复用 将多路基带信号调制到不同频率载波上，再叠加成为一个复合信号的多路复用技术。 - 信道频谱划分为若干频带 (frequency bands) - 每个站点分配一个固定的频带 - 无传输频带空闲</p><h5 id="others">others</h5><p>CDMA 码分：采用不同的编码来区分各路原始信号，即共享频率又共享时间 WDMA 波分：广播的频分多路复用。</p><h4 id="随机访问">随机访问</h4><p>随机访问协议不采用集中控制方式解决发送消息的次序问题，用户根据意愿随机地发送消息，占用信道的全部速率。 为了解决随机接入发生的碰撞，每个用户需要按照一定的规则重传帧，这些规则就是随机访问介质传输协议。 常用的有 ALOHA, CSMA, CSMA/CD, CSMA/CA</p><ul><li>当结点要发送分组时：<ul><li>利用信道全部数据速率R发送分组</li><li>没有事先的结点间协调</li></ul></li><li>两个或多个结点同时传输：➜ “冲突”</li><li>随机访问MAC协议需要定义:<ul><li>如何检测冲突</li><li>如何从冲突中恢复 (e.g., 通过延迟重传)</li></ul></li><li>典型的随机访问 MAC 协议：<ul><li>时隙(sloted)ALOHA</li><li>ALOHA</li><li>CSMA、CSMA/CD、CSMA/CA</li></ul></li></ul><h5 id="aloha">ALOHA</h5><h6 id="纯-aloha">纯 ALOHA</h6><p>思路是：直接发送帧，如果一段时间内未收到确认即认定为发送成功，否则认定为冲突。 如果产生了冲突，说明起码会有两个发送有问题，不能立即重发，所以重传策略为随即等待一段时间再发送。</p><h6 id="时隙-aloha">时隙 ALOHA</h6><p>由于纯 ALOHA 非常的简单，实际上的网络吞吐量很低，于是改进了时隙 ALOHA 协议。</p><p>假定： - 所有帧大小相同 - 时间被划分为等长的时隙 (每个时隙可以传输1个帧) - 结点只能在时隙开始时刻发送帧 - 结点间时钟同步 - 如果 2 个或 2 个以上结点在同一时隙发送帧，结点即检测到冲突</p><p>运行: - 当结点有新的帧时，在下一个 时隙(slot)发送 - 如果无冲突：该结点可以在下一个时隙继续发送新的帧 - 如果冲突：该结点在下一个时隙以概率p重传该帧，直至成功</p><p>优点: - 单个结点活动时，可以连续以信道全部速率传输数据 - 高度分散化：只需同步时隙 - 简单</p><p>缺点: - 冲突，浪费时隙 - 空闲时隙 - 结点也许能以远小于分组传输时间检测到冲突 - 时钟同步</p><p>效率： - 假设: N 个结点有很多帧待传输，每个结点在每个时隙均以概率p发送数据 - 对于给定的一个结点，在一个时隙将帧发送成功的概率：<span class="math inline">\(p(1-p)^{N-1}\)</span> - 对于任意结点成功发送帧的 概率：<span class="math inline">\(Np(1-p)^{N-1}\)</span> - 最大效率: 求得使 <span class="math inline">\(Np(1-p)^{N-1}\)</span> 最大的 p* - 对于很多结点，求 <span class="math inline">\(Np*(1-p*)^{N-1}\)</span> 当 N 趋近无穷时的极限，可得:最大效率 <span class="math inline">\(1/e = 0.37\)</span> - 最好情况: 信道被成功利用的时间仅占 37%！</p><h5 id="csma">CSMA</h5><p>载波监听多路访问 (carrier sense multiple access) - 发送帧之前，监听信道(载波)： - 信道空闲：发送完整帧 - 信道忙：推迟发送 - 1-坚持 CSMA - 非坚持 CSMA - P-坚持 CSMA - 冲突可能仍然发生：信号传播延迟 |信道状态|1-坚持|非坚持|p-坚持| |-------|------|-----|------| |空闲|立即发送数据|立即发送数据|以概率 <span class="math inline">\(p\)</span> 发送数据，以概率 <span class="math inline">\(1-p\)</span> 推迟到下一时隙| |忙|继续坚持侦听|放弃侦听，等随机时间后再侦听|继续侦听，直至空闲|</p><p>CSMA/CD: CSMA with Collision Detection - 短时间内可以检测到冲突 - 冲突后传输中止，减少信道浪费 “边发边听，不发不听”</p><p>其实总结一下工作流程： “先听后发、边听边发、冲突停发、随机重发”</p><ul><li>冲突检测:<ul><li>有线局域网易于实现：测量信号强度，比较发射信号与接收信号</li><li>无线局域网很难实现：接收信号强度淹没在本地发射信号强度下</li></ul></li></ul><p>CSMA/CD 效率： <span class="math inline">\(T_{prop}\)</span>: LAN 中 2 个结点间的最大传播延迟 <span class="math inline">\(t_{trans}\)</span>: 最长帧传输延迟 <span class="math inline">\(e = \dfrac{1}{1+5t_{prop}/t_{trans}}\)</span> - <span class="math inline">\(t_{prop} \rightarrow 0\)</span> 或者 <span class="math inline">\(t_{trans} \rightarrow \infty\)</span> 时，效率趋近 1 - 远优于 ALOHA</p><h4 id="轮询访问">轮询访问</h4><p>信道划分 MAC 协议： - 网络负载重时，共享信道效率高，且公平 - 网络负载轻时，共享信道效率低！ 随机访问 MAC 协议： - 网络负载轻时，共享信道效率高，单个结点可以利用信道的全部带宽 - 网络负载重时，产生冲突开销</p><p>轮转访问MAC协议： 综合两者的优点！</p><p>轮询：</p><p>令牌传递：</p><p>总结两个轮转访问 MAC 协议：轮询和令牌传递的共同点和不同点？ - 共同点： - 开销 - 等待延迟 - 单点故障 - 无冲突 - 信道预约 + 数据传输 - 不同点： - 轮询：集中式预约（分配）信道 - 令牌：分布式预约信道 能否设计一个新的轮转访问 MAC 协议？</p><p>比特映像介质访问控制协议: - 将时间划分成一系列的预约周期和数据传输周期 - 每个预约周期包括 N 个时隙，每个时隙 1 比特，对应一个站 - 任何一个站想发送数据，必须在它的时隙到来时发一个“1” - 当预约周期结束后，所有站都知道有哪些站希望发送数据，于是 这些预约过的站按编号顺序发送，永不冲突 - 最后一个站发完数据后，开始新一轮的预约周期</p><h4 id="mac-总结">MAC 总结</h4><ul><li>信道划分 MAC 协议：时间、频带、码片划分<ul><li>TDMA、FDMA、CDMA</li></ul></li><li>随机访问MAC协议：<ul><li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li><li>CSMA/CD应用于以太网</li><li>CSMA/CA应用802.11无线局域网</li></ul></li><li>轮转访问 MAC 协议：<ul><li>主结点轮询；令牌传递；比特映像介质访问控制</li><li>蓝牙、FDDI、令牌环网</li></ul></li></ul><h3 id="局域网技术">局域网技术</h3><h4 id="总览-1">总览</h4><p>局域网 (Local Area Nework) 是指在一个较小地理范围内将计算机、外部设备和数据库系统等通过连接介质连接起来的计算机网络。 它能够进行广播和组播，并且互相间是平等的关系。 局域网的拓扑结构： 1. 星形：中心 2. 总线型：单个故障影响小 3. 环形 有几种特殊的局域网拓扑实现： 1. 以太网：逻辑结构总线型，物理拓扑星形或者是拓展星形 2. 令牌环 (Token Ring, IEEE 802.5)：逻辑环形：物理星形 3. FDDI(IEEE 802.8)：逻辑环形，物理双环</p><h4 id="mac-地址">MAC 地址</h4><p>为了满足链路层寻址<strong>唯一</strong>的关键需求，使用了 MAC 地址。 MAC 地址（或者说是 LAN 地址，物理地址，以太网地址）: - 作用：局域网内标识一个帧从哪个接口发出，并且需要到达哪个接口 - 局域网中的每块网卡都有一个唯一的 <strong>MAC 地址</strong> - 48 位 MAC 地址，固化在网卡的 ROM 中，有时也可以软件设置。 - e.g.: 1A-FF-BB-76-09-AD - 广播地址：FF-FF-FF-FF-FF-FF - 由 IEEE 统一管理和分配 - 网卡生产商购买 MAC 地址空间（前 24 比特） - 一个类比： - MAC 地址：身份证号 - IP 地址：邮政地址</p><p>IP 地址： - 32 位 (IPv4) - 接口的网络层地址 - 用于标识网络层（第三层）分组，支持分组转发</p><p>MAC 地址是“平面”地址：➜ 可“携带” - 可以从一个 LAN 移动到另一个 LAN IP 地址是层次地址：➜ 不可“携带” - IP地址依赖于结点连接到哪个子网</p><h4 id="以太网">以太网</h4><p>是造价低廉、应用最广泛、比令牌局域网和 ATM 等简单便宜，满足 10 Mbps 到 10 Gbps 速率需求的统治级别的局域网技术。</p><p>以太网的物理拓扑模型： - 总线 (bus): 上世纪 90 年代中期前流行 - 所有结点在同一冲突域 (collision domain) (可能彼此冲突) - 同轴电缆 - 星型 (star): 目前主流网络拓扑 - 中心交换机 (switch) - 每个结点一个单独冲突域（结点间彼此不冲突）</p><p>以太网：不可靠、无连接服务 - 无连接 (connectionless): 发送帧的网卡与接收帧的网卡间没有“握手”过程 - 不可靠 (unreliable): 接收网卡不向发送网卡进行确认 - 差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议 (e.g., TCP)，否则，发生数据丢失 - 以太网的MAC协议: 采用二进制指数退避算法的 CSMA/CD</p><p>以太网的 CSMA/CD 算法 1. NIC 从网络层接收数据报，创建数据帧。 2. 监听信道：如果 NIC 监听到信道空闲，则开始发送帧；如果 NIC 监听到信道忙，则一直等待到信道空闲，然后发送帧。 3. NIC 发送完整个帧，而没有检测到其他结点的数据发送，则 NIC 确认帧发送成功！ 4. 如果 NIC 检测到其他结点传输数据，则中止发送，并发送堵塞信号 (jam signal) 5. 中止发送后，NIC 进入二进制指数退避： - 第m次连续冲突后： - 取 n = Min(m, 10) - NIC 从 {0,1,2, …, 2n-1} 中随机选择一个数 K - NIC 等待 K·512 比特的传输延迟时间，再返回第 2 步 - 连续冲突次数越多，平均等待时间越长。</p><p>以太网帧结构： <img src="/imgs/CompNet/链路层/以太网帧结构.png" alt="以太网帧结构" /> - 前导码 (Preamble)(8B): - 7 个字节的 10101010，第 8 字节为 10101011 - 用于发送端与接收端的时钟同步 - 通常不计入帧长 - 目的 MAC 地址、源 MAC 地址 (各 6B): - 如果网卡的 MAC 地址与收到的帧的目的 MAC 地址匹配，或者帧的目的 MAC 地址为广播地址 (FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。 - 否则，网卡丢弃（不接收）该帧。 - 类型 (Type)(2B): 指示帧中封装的是哪种高层协议的分组 （如，IP 数据报、Novell IPX 数据报、AppleTalk 数据报等） - 数据(Data)(46-1500B): 指上层协议载荷。 - <span class="math inline">\(R = 10 Mbps, RTT_{max} = 512μs, L_{min} / R = RTT_{max}\)</span> - <span class="math inline">\(L_{min} = 512bits=64B, Data_{min} = L_{min}-18=46B\)</span> - CRC(4B): 循环冗余校验码 - 丢弃差错帧</p><p>以太网标准： - 相同的MAC协议和帧格式 - 不同速率: 2 Mbps, 10 Mbps, 100 Mbps, 1 Gbps, 10 Gbps，40Gbps - 不同物理介质: 光纤，线缆 - 100Base-T：快速以太网</p><p>链路层设备 VS. 物理层设备 |-|集线器 (hub)|交换机 (switche)| 网桥 (bridge)| |-|-----------|----------------|-------------| |层次|1|2|2| |流量（冲突域）隔离|no|yes|yes| |广播域隔离|no|no|no| |即插即用|yes|yes|yes| |优化路由|no|no|no| |直通传输|yes|yes|yes|</p><h3 id="ppp-协议">PPP 协议</h3><h4 id="引入-简介">引入 &amp; 简介</h4><p>首先介绍广域网，是覆盖距离很广的长距离网络。 |-|广域网|局域网| |覆盖范围|广|小| |连接方式|点对点|多点接入| |OSI|物理层、链路层、网络层|物理层、链路层| |强调|资源共享|数据传输|</p><p>*点对点的数据链路控制： - 一个发送端，一个接收端，一条链路：比广播链路容易 - 无需介质访问控制 (Media Access Control) - 无需明确的 MAC 寻址 - e.g., 拨号链路，ISDN 链路 - 常见的点对点数据链路控制协议（广域网）： - HDLC: High Level Data Link Control - <strong>PPP (Point-to-Point Protocol)</strong></p><ul><li>PPP (Point-to-Point Protocol) 协议由 IETF 制定，1994 年成为正式标准 (RFC1661)</li><li>PPP 协议是目前使用最多的数据链路层协议之一</li><li>能够在不同的链路上运行</li><li>能够承载不同的网络层分组</li><li>特点：简单、灵活</li></ul><p>设计需求： - 组帧：将网络层数据报封装到数据链路层帧中 - 可以同时承载任何网络层协议分组（不仅 IP 数据报） - 可以向上层实现分用（多路分解） - 比特透明传输：数据域必须支持承载任何比特模式 - 异步传输时：字节填充 - 同步传输时：零比特填充 - 差错检测——无纠正 - 连接活性 (connection liveness) 检测：检测、并向网络层 通知链路状态 - 网络层地址协商：端结点可以学习/配置彼此网络地址</p><h4 id="ppp-数据帧">PPP 数据帧</h4><p><img src="/imgs/CompNet/链路层/PPP数据帧.png" alt="PPP数据帧" /> - 标志 (Flag): 定界符 (delimiter) - 地址 (Address): 无效 (仅仅是一个选项) - 控制 (Control): 无效；未来可能的多种控制域 - 协议 (Protocol): 上层协议 (eg, PPP-LCP, IP, IPCP, etc) - 信息 (info): 上层协议分组数据 - 校验 (check): CRC 校验，用于差错检测</p><p>PPP 协议的透明传输和 PPP 数据控制协议具体看 PPT 吧。</p><h4 id="pppoe">PPPoE</h4><ul><li>Ethernet 优点<ul><li>原理简单，应用非常广，设备成本低</li></ul></li><li>Ethernet 缺点<ul><li>安全性较低、不宜管理：使用广播信道，造成了安全性较低，无认证功能</li></ul></li><li>PPP优点</li><li>原理简单<ul><li>安全性高：点对点信道，提供认证机制</li><li>提供良好的访问控制和计费功能</li></ul></li></ul><p>PPPoE(Point-to-Point Protocol over Ethernet) - 提供在<strong>以太网链路上的 PPP 连接</strong> - 实现了传统以太网不能提供的身份验证、加密，以及压缩等功能 - 实现基于用户的访问控制、计费、业务类型分类等，运营商广泛支持 - PPPoE 使用 Client/Server 模型，服务器通常是接入服务器</p><p>PPPoE可分为三个阶段： - Discovery阶段 − 获取对方以太网地址，确定PPPoE会话ID - Session阶段 − PPP协商阶段 − PPP报数数据传输 - Terminate阶段 − 会话建立以后的任意时刻，发送报文结束会话</p><!-- ### 链路虚拟化 --><h2 id="总结">总结</h2><p>其实内容还挺多，应该分成两部分写的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>数据链路层</tag>
      
      <tag>局域网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.2 物理层</title>
    <link href="/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-2-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-2-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><p>物理层的结构是自下而上的<strong>第一层</strong>，物理层考虑的是怎样才能在连接各台计算机 这一部分的内容主要是学习： - 了解物理层的主要功能 - 理解数据通信的相关概念和基本原理 - 掌握物理传输介质的特性 - 掌握信道、信道容量的概念和计算 - 掌握多路复用技术 - 理解基带传输与频带传输 - 理解基带传输的典型编码与频带传输的典型调制技术</p><h2 id="内容">内容</h2><h3 id="物理层基本功能">物理层基本功能</h3><p>物理层实现的功能，简单的说实际上是在特定的物理环境或物理介质上实现一个比特或一个比特流的传输。 它是在连接节点的物理介质上实现比特流传输。 它涉及到了如何进行比特编码，用什么样的信号，什么样的特征表示，数据率如何基于比特如何同步，传输是什么模式等待。 物理层的接口特性有 - 机械特性（形状尺寸等）、电气特性（电压范围等）、功能特性（指明某一电平的电压有何意义）、规程特性 - 时钟同步 传输模式有：单工（Simplex）、半双工（half-duplex）、全双工（full-duplex）</p><h3 id="数据通信基础">数据通信基础</h3><h4 id="数据通信系统模型">数据通信系统模型</h4><p>对于数据通信系统，模型如图所示： <img src="/imgs/CompNet/数据通信系统模型.png" alt="数据通信系统模型" /> 其中，信源和发送设备是发送端，接收设备和信宿是接收端。</p><p>P.S. 这个图是单向的模型，而实际上的通信系统大多数是双向的，往往包含一条发送信道和一条接收信道。</p><ul><li>信源：将消息转化为信号的设备</li><li>发送设备：将信源产生的信号进行适当变换的装置，使之适合在信道中传输。主要包括编码和调制</li><li>信道：信号传输通道（eg: 物理介质）</li><li>噪声：自然界和通信设备中产生的干扰</li><li>接受设备：完成发送设备反变换，还原原始发送信号</li><li>信宿：信号终点，将信号转换为人们能够识别的消息</li></ul><h4 id="常见数据通信术语">常见数据通信术语</h4><ul><li>“模拟的” (analogous)：参数的取值是连续的</li><li>“数字的” (digital) ：参数的取值是离散的</li><li>码元 (code) ：信号基本波形（信号基本单元）</li><li>频带 (spectrum) ：信号频率范围 (Hz)</li><li>带宽 (bandwidth) ：有效带宽</li><li><p>数据通信方式：单工、半双工、全双工 &gt; 单工：只有一个方向，没有反方向的交互方式，仅需要一条信道 </br> 半双工：通信的双方都可以发送或接收信息，但是任何一方都不能同时发送和接受信息，所以需要两条信道 </br> 全双工：双方可以同时收发信息，但是还是需要两条信道</p></li><li><p>串行通信 vs 并行通信</p></li><li><p>同步通信 vs 异步通信 是发送器 (Transmitter, Tx) 与接收器 (Receiver, Rx) 之间的时钟同步问题。 主要有同步和异步两种解决方案。</p></li><li>异步<ul><li>每次传输一个字符<ul><li>5 to 8 bits</li></ul></li><li>发送器和接收器分别使用各自独立的时钟</li><li>只需在每个字符传输期间保证时钟同步即可</li><li>两个字符之间始终不需要同步</li><li>每个字符传输开始同步时钟</li><li>字符之间间隔时间不一致</li><li>空闲状态下，接收器检测 1 到 0 的跳变，然后开始采样（一个字符长度）</li><li>之后回归空闲状态，再次检测 1 到 0 的跳变。</li><li>+: 简单、低成本</li><li>-: 开销大，每个字符有 2 或 3 位开销</li><li>适合短距离、低速率、字符间隔时间大（比如键盘）等通信场景</li></ul></li><li>同步<ul><li>（大）数据块传输</li><li>时钟必须同步</li><li>可以使用单独的时钟线<ul><li>适合短距离</li><li>时钟信号损伤</li></ul></li><li>将时钟信号嵌入到数据信号中<ul><li>曼彻斯特编码</li><li>载波频率</li></ul></li><li>比异步通信更<strong>高效</strong>（开销少）</li></ul></li><li><p>模拟通信 vs 数字通信 区别在于信道中传输的是模拟信号（连续）还是数字信号（离散）</p></li></ul><h4 id="信源编码">信源编码</h4><p>Q: 如果信源产生的是模拟数据，如何在数字通信系统中传输？ A: 信源编码 一个典型的信源编码是——PCM，其包括三个步骤： 采样 -&gt; 量化 -&gt; 编码 采样：目的是用一系列在时间上离散的采样值，代替时间上连续的模拟数据，实现时间上的离散化 量化：使得采样值在取值上离散化 编码：量化后的采样值用一定位数的二进制数码来表示，如果量化的级数为 <span class="math inline">\(N\)</span>，则每个采样值就编码成 <span class="math inline">\(log_2N\)</span> 位二进制码</p><p>PCM 的转换过程是通过将原始信号（连续信号）取值转化为 PAM 脉冲（在某几个位置取值取点）， 再进行量化成为 PCM 脉冲（比如说取整），最后编码 PCM 输出。</p><h4 id="扩频">扩频</h4><p>扩频 (Spread Spectrum)： - 模拟或数字数据 - 模拟信号 - 将数据的传输（调制）扩展到更宽的频带上 - 制造干扰使通信不易被窃听 - 跳频 (Frequency Hoping) - 载波信号频率在一组频率上随机（某种规律跳变） - <del>由好莱坞女星发明</del> - 直接序列扩频 (Direct Sequence Spread Spectrum) - 通过传输多个比特表示原始信息的一个比特 - 碎码序列</p><h3 id="物理介质">物理介质</h3><h4 id="导引型">导引型</h4><p>直接上 PPT 的图吧！ <img src="/imgs/CompNet/物理层/导引型1.png" alt="导引型1" /> <img src="/imgs/CompNet/物理层/导引型2.png" alt="导引型2" /></p><h4 id="非导引型">非导引型</h4><p>也是直接上图吧！ <img src="/imgs/CompNet/物理层/非导引型1.png" alt="非导引型1" /> <img src="/imgs/CompNet/物理层/非导引型2.png" alt="非导引型2" /> <img src="/imgs/CompNet/物理层/非导引型3.png" alt="非导引型3" /></p><h3 id="信道与信道容量">信道与信道容量</h3><p>信道： - 狭义：信号传输介质 - 广义：包括传输介质和通信系统的一些变换装置</p><p>传输特性： - 恒参信道传输特性 - 各种有线信道和部分无线信道，如微波视线传播链路和卫星 链路 等，都属于恒参信道 - 理想的恒参信道是一个理想的无失真传输信道 - 对信号幅值产生固定的衰减 - 对信号输出产生固定的时延 - 随参信道传输特性 - 许多无线信道都是随参信道 - 信号的传输衰减随时间随机变化 - 信号的传输时延随时间随机变化 - 存在多径传播现象</p><p>信道容量： 信道容量是指信道无差错涮熟信息的<strong>最大</strong>平均信息速率 - 奈奎斯特 (Nyquist) 信道容量公式 - 理想无噪声的信道容量： <span class="math inline">\(C = 2Blog_2M\)</span> - <span class="math inline">\(C\)</span> 为信道容量，单位为 <span class="math inline">\(b/s (bps)\)</span>；<span class="math inline">\(B\)</span> 为信道带宽，单位为 <span class="math inline">\(Hz\)</span>；<span class="math inline">\(M\)</span> 为进制数，集信号状态数 - 是理想信道的极限容量 - eg.1: - Q: 在无噪声情况下，若某通信链路的带宽为 <span class="math inline">\(3 kHz\)</span>，采用 <span class="math inline">\(4\)</span> 个相位、每个相位具有 <span class="math inline">\(4\)</span> 种振幅的 <span class="math inline">\(QAM\)</span> 调制技术，则该通信链路的最大数据传输速率是多少？ - A: <span class="math inline">\(24 kbps\)</span> 对于这个信道容量公式，可以得出这样的结论： - 任何信道中，码元传输速率是邮上线的，如果速率超过上限，就会出现严重的码间串扰问题 - 信道的频带越宽，速率就可以更高 - 这个公式给出了码元传输速率的限制，但是未对信息传输速率限制 如果想要提高传输速率，需要设法使得码元携带更多比特的信息量。</p><ul><li>香农 (Shannon) 信道容量公式<ul><li>有噪声的信道容量： <span class="math inline">\(C = Blog_2(1+S/N)\)</span></li><li><span class="math inline">\(S/N\)</span> 为信噪比，信号能量与噪声能量之比</li><li><span class="math inline">\(S/N\)</span> 通常以分贝为单位描述<ul><li><span class="math inline">\((S/N)_{dB} = 10log_{10}(Singal\ power/ Noise\  Power)\)</span></li></ul></li></ul></li><li>eg.2<ul><li>Q: 若某通信链路的带宽为 <span class="math inline">\(2 MHz\)</span>，信噪比为 <span class="math inline">\(30 dB\)</span>，则该通信链路的最大数据传输速率约是多少？</li><li>A: <span class="math inline">\(20 Mbps\)</span></li></ul></li></ul><p>同样可以得到一些结论： - 信噪比越大，信息的极限传输速率越高 - 如果信息传输速率低于极限传输速率，那么可以找到方法实现无差错的传输 - 他只是极限速率，实际速率会低不少</p><h3 id="信道共享">信道共享</h3><p>首先是多路复用啊 <img src="/imgs/CompNet/物理层/多路复用.png" alt="多路复用" /> <img src="/imgs/CompNet/物理层/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png" alt="多路复用2" /> 这里大概的给出点东西，实际上还看 PPT 更详细清楚一些。 - 频分多路 FDM - 个用户占用不同的带宽资源 - 时分多路 TDM - 将时间划为等长的 <strong>时分复用帧</strong>，每个用户在每个 TDM 帧中占用固定序号的时隙 - 每个用户占用的时隙是 <strong>周期性出现</strong> 周期即为 TDM 帧的长度 - 时分复用的所有用户是在不同时间占用<strong>相同的</strong>频带宽度 - 波分多路 WDM - 光的频分复用 - 码分多路 CDM - 为用户分配一个唯一的 m bit 的码片序列</p><h3 id="基带传输">基带传输</h3><p>看 PPT 比较直观</p><h3 id="频带传输">频带传输</h3><p>看 PPT 比较直观</p><h3 id="物理层设备">物理层设备</h3><figure><img src="/imgs/CompNet/物理层/物理层设备.png" alt="物理层设备" /><figcaption>物理层设备</figcaption></figure><h2 id="总结">总结</h2><ul><li>物理层最基本功能是实现在物理介质上传输比特率流</li><li>实现物理层功能的技术就是数据通信技术</li><li>数据通信系统相关概念与基本原理</li><li>物理传输包括导引型介质和非导引型介质</li><li>奈奎斯特公式和香农公式给出了理想无噪声信道和有噪声信道 的信道容量的上限</li><li>多路复用技术是实现信道共享的典型技术，包括TDM、FDM、 WDM和CDM等</li><li>数据通信的两类传输技术是基带传输与频带传输，有线链路的 局域网中常采用基带传输，宽带网络、无线网络、光网络等多 采用频带传输</li><li>中继器和集线器是典型物理层设备，工作原理是相同的</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>物理层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 Ch.1 Intro</title>
    <link href="/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-1-Intro/"/>
    <url>/2022/03/24/ComputerNetwork/%E8%AE%A1%E7%BD%91-Ch-1-Intro/</url>
    
    <content type="html"><![CDATA[<h3 id="引言">1.0 引言</h3><p>大概就是一个概述： 这里的内容主要参考自：</p><h3 id="基本概念">1.1 基本概念</h3><p>计算机网络？ 网络协议？ 网络分类？ #### 网络 定义：计算机网络是<strong>互联的</strong>、<strong>自治的</strong>计算机集合。 - 互联——互联互通 - 通信链路 - 自治——无主从关系 计算机网络通过交换网络连接主机。</p><h4 id="协议">协议</h4><p>协议的三要素 - 语法 (Syntax) - 数据与控制信息的结构或格式 - 信号电平 - 语义 (Semantics) - 需要发出何种控制信息 - 完成何种动作以及做出何种响应 - 差错控制 - 时序 (Timing) - 时间顺序 - 速度匹配 协议规范了网络中所有信息的发送和接收过程。</p><h4 id="网络分类">网络分类</h4><ul><li>按照网络覆盖范围分类：<ul><li>个人区域网PAN (Personal Area Network) ~10米</li><li>局域网LAN (Local Area Network) ~1公里</li><li>城域网MAN (Metropolitan Area Network) ~5-50公里</li><li>广域网WAN (Wide Area Network) ~几十-几千公里</li></ul></li><li>按照网络使用者分类：<ul><li>专用网(private network)</li><li>公用网(public network)</li></ul></li><li>按照网络拓扑分类：<ul><li>总线网络</li><li>星形网络</li><li>树形网络</li><li>网状网络</li></ul></li></ul><h3 id="结构">1.2 结构</h3><p>网络边缘、接入网络、网络核心、Internet 结构 看看 PPT ?</p><h3 id="数据交换">1.3 数据交换</h3><p>电路交换、报文交换、分组交换 数据交换是数据通过网络核心从源主机到达目的主机的方式。 #### 三种交换形式 电路交换： - 最典型的电路交换网络：电话网络 - 电路交换的三阶段 - 建立连接 - 通信 - 释放连接 - 独占资源</p><p>报文交换是一种将信息整体发送的形式。</p><p>分组是报文分拆出来的一系列相对较小的数据包，进行分组交换需要将报文进行拆分和重组，这意味着它将产生额外开销。</p><h4 id="报文交换-vs-分组交换">报文交换 vs 分组交换</h4><p>首先引入传输延迟的概念： <span class="math inline">\(delay = \dfrac{L(bits)}{R(bits/sec)}\)</span> - 拆分为较小长度为 <span class="math inline">\(L bits\)</span> 的分组(packets) - 在传输速率为 <span class="math inline">\(R\)</span> 的链路上 传输分组</p><p>那么来看一个报文交换和分组交换的例子： 报文交换 - 报文长度 <span class="math inline">\(M\)</span> bits - 链路带宽为 <span class="math inline">\(R\)</span> bps - 每次传输报文需要 <span class="math inline">\(M/R\)</span> 秒 分组交换： - 报文被拆分为多个分组 - 分组长度为 <span class="math inline">\(L\)</span> bits - 每个分组传输时延为 <span class="math inline">\(L/R\)</span> 秒 &gt; eg: </br> 配一张图，大概是 PC-设备-设备-PC M = 7.5 Mbits, L = 1500 bits (M = 5000L) </br> R = 1.5 Mbps </br> 报文交换的交付时间为: M / R = 7.5 / 1.5 = 5 s 总时间为 5 * 3 = 15 s。 分组交换的交付时间为: 因为已经分了 5000 组，一个组传输一段的用时为 <span class="math inline">\(L/R = 1500/(1.5 \times 10^6) = 1 \ ms\)</span> 想象一个这样的情况，从第一组开始，用时 1ms 出发到达第一个中途交换机，这样第二组也可以开始出发了，那么到第 5000 组出发的时候，已经经过了 4999 个 1ms，第 5000 组再走 3 段路就可以全部送达了！所以总共需要： <span class="math inline">\(1ms \times (4999 + 3) = 5002ms\)</span> <span class="math inline">\(5002 ms = 5.002 s\)</span></p><p>总结一个分组交换的报文交付时间如下： - 报文：<span class="math inline">\(M bits\)</span> - 链路带宽：<span class="math inline">\(R bps\)</span> - 分组长度（大小）：<span class="math inline">\(L bits\)</span> - 跳步数：<span class="math inline">\(h\)</span> - 路由器数：<span class="math inline">\(n\)</span> 那么有： <span class="math inline">\(T = M/R + (h-1)L/R = M/R + nL/R\)</span></p><blockquote><p>例题again: </br> H1-&gt;设备0-&gt;设备1-&gt;H2; </br> H1-&gt;设备0-&gt;设备2-&gt;设备1-&gt;H2 </br> 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为 100 Mbps，分组大小为 1 000 B，其中分组头大小为 20 B。若主机H1向主机H2发 送一个大小为 980 000 B 的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到 H2 接收完为止，需要的时间至少是？ </br> 首先计算一下分组：</br> 巧了，正好分组大小和分组头大小组合一下，就可以让 980 B 的文件和 20 B 的分组头一起凑成 1 000 B，那么正好可以分成 1000 组。</br> 那么整个文件的延迟：<span class="math inline">\(M/R = (1000 \times 1000B) \times 8 / (100 \times 10^6 bps) = 80ms\)</span></br> 有一个路由选择基本原理，所有数据分组应该经过两个路由器的转发，用时最少，所以总时间只需要再加上最后一个分组的两次转发延迟，即为：</br> <span class="math inline">\(2 \times (2 \times 1000B) \times 8 / (100 \times 10^6 bps) = 0.16ms\)</span></br> 于是总时间：<span class="math inline">\(80+0.16=80.16ms\)</span></p></blockquote><h3 id="性能指标">1.4 性能指标</h3><p>速率、带宽、时延、时延带宽积、吞吐量 #### 速率和带宽 速率是数据传输速率或是比特率</p><p>带宽是信号具有的频带宽度，最高频率与最低频率之差（原本定义） 但是网络中的带宽是指数字信道传送的<strong>最高数据率</strong></p><h4 id="延迟时延">延迟/时延</h4><p>Q: 分组交换为什么会发生时延和丢包？ A: 分组在路由器缓存中排队 - 分组到达速率超出链路容量时 - 分组排队，等待输出链路可用</p><p>四种分组延迟： <span class="math inline">\(d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}\)</span> <img src="/imgs/CompNet/分组延迟.png" alt="分组延迟" /> <span class="math inline">\(d_{proc}\)</span>: 节点处理延迟 - 差错检测 - 确定输出链路 - 通常 &lt; msec</p><p><span class="math inline">\(d_{queue}\)</span>: 排队延迟 - 等待输出链路可用 - 取决于路由器拥塞程度</p><p><span class="math inline">\(d_{trans}\)</span>: 传输延迟 - <span class="math inline">\(L\)</span>: 分组长度 (bits) - <span class="math inline">\(R\)</span>: 链路带宽 (bps) - <span class="math inline">\(d_{trans} = L/R\)</span></p><p><span class="math inline">\(d_{prop}\)</span>: 传播延迟 - <span class="math inline">\(d\)</span>: 物理链路长度 - <span class="math inline">\(s\)</span>: 信号传播速度 (~2*10^8m/sec) - <span class="math inline">\(d_{prop}=d/s\)</span></p><h4 id="利用率">利用率</h4><p><span class="math inline">\(U = \dfrac{t_{PKT}}{t_{PKT} + RTT + t_{ACK}}\)</span></p><h4 id="分组丢失丢包">分组丢失（丢包）</h4><ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃（即丢包）</li><li>丢弃分组可能由前序结点或源重发（也可能不重发） <span class="math inline">\(丢包率=\dfrac{丢包数}{已发分组总数}\)</span></li></ul><h4 id="吞吐量率">吞吐量/率</h4><ul><li>吞吐量:表示在发送端与接收端之间传送数据速率 (b/s)<ul><li>即时吞吐量: 给定时刻的速率</li><li>平均吞吐量: 一段时间的平均速率</li></ul></li></ul><p><img src="/imgs/CompNet/eg01.png" alt="eg01" /> <img src="/imgs/CompNet/eg02.png" alt="eg02" /> <img src="/imgs/CompNet/eg03.png" alt="eg03" /> <img src="/imgs/CompNet/eg04.png" alt="eg04" /></p><h3 id="体系结构">1.5 体系结构</h3><p>OSI 参考模型、TCP/IP 参考模型、五层参考模型</p><p>OSI: 物理层、链路层、网络层、传输层、会话层、表示层、应用层（共 7 层） - 理论学习工具（理论成功、市场失败）</p><p>TCP/IP: 物理层、数据链路层、网络层、传输层、应用层</p><h3 id="发展历史">1.6 发展历史</h3><p>略</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part10 动态规划 子序列</title>
    <link href="/2022/03/13/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4.%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/03/13/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4.%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a> 简简单单用 <code>dp[i]</code> 标记一个位置在 i 处的包含其本体在内的最长子序列长度。 接下来就是对之后的元素继承延申其内容就可以了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            result = result &gt; dp[i] ? result : dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">最长连续递增序列</a> <del>简简单单，用贪心更方便</del> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>])<br>                now++;<br>            <span class="hljs-keyword">else</span><br>                now = <span class="hljs-number">1</span>;<br>            ans = Math.max(now, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a> 要求是连续的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a> 有一个网站很有意思 <a href="http://lcs-demo.sourceforge.net/">LCS 可视化</a>。 对于字符串 <span class="math inline">\(text_1\)</span> 和 <span class="math inline">\(text_2\)</span>，考虑创建一个二维数组 <span class="math inline">\(dp\)</span> 用于储存不同状态下的最长公共子序列长度。 <span class="math inline">\(dp[i][j]\)</span> 储存 <span class="math inline">\(text_1\)</span> 的前 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(text_2\)</span> 的前 <span class="math inline">\(j\)</span> 位字符组成的子串的最长公共子序列长度。 对于 <span class="math inline">\(dp[i][j]\)</span> 而言，其状态转移依赖于 <span class="math inline">\(dp[i-1][j], dp[i][j-1]\)</span> 和 <span class="math inline">\(dp[i-1][j-1]\)</span> ，其中应用到 <span class="math inline">\(dp[i-1][j-1]\)</span> 的情况来自于 <span class="math inline">\(text_1[i] == text_2[j]\)</span> 匹配的情况，所以可以直接继承自不含这个字符的它们的子串的情况，另外两个则是作为最大值的选择（反正都匹配不上了，不如互相退一步，看看哪个的子串长）。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i-<span class="hljs-number">1</span>) == text2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/uncrossed-lines/">不相交的线</a> 实际上就是求两个序列的按顺序的最长子序列。 所以本质上和 <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a> 相同，题解不单独列出来了。</p><p><a href="https://leetcode-cn.com/problems/is-subsequence/">判断子序列</a> 一个基础的编辑距离，一样的思路 <del>双指针很方便</del> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length2</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length1+<span class="hljs-number">1</span>][length2+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= length1; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= length2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[length1][length2] == length1) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a> 双指针做不到的来了…… 列个表吧： | | |r|a|b|b|i|t| |-|-|-|-|-|-|-|-| | |1|0|0|0|0|0|0| |r|1|1|0|0|0|0|0| |a|1|1|1|0|0|0|0| |b|1|1|1|1|0|0|0| |b|1|1|1|2|1|0|0| |b|1|1|1|3|3|0|0| |i|1|1|1|3|3|3|0| |t|1|1|1|3|3|3|3|</p><p>状态转移有： $ dp[i][j] = { \begin{array}{l} dp[i-1][j] , (s_i 和 t_j 不匹配) \ \ dp[i-1][j-1] + dp[i-1][j] , (s_i 和 t_j 匹配) \end{array} . $ 如何理解呢？ 首先是不匹配的情况，这种情况下，串 s 子序列能够拼凑成串 t 的子序列的数量应该和同样匹配这一串 t 的子序列，同时当前 s 子串又少最后一个字符的情况相同，毕竟也匹配不上，少你多你没区别。 如果是匹配的话，就可以再加上两者都少一个字符的情况啦！</p><p><del>巴巴巴尼，巴巴巴尼巴尼</del> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a> 我其实更偏好求最长公共子序列后相减。。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (m + n - <span class="hljs-number">2</span>*dp[m][n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列</a> 把一个串返回来就是回文了！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>原本一位只是子序列核心的部分，然后想直接承接算法课学过的内容上手的，然后好像还是有点不一样。 因为实际上构造数组的时候还是需要辅助行/列的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part10 动态规划 打劫和股票</title>
    <link href="/2022/03/12/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3.%E6%89%93%E5%8A%AB%E5%92%8C%E8%82%A1%E7%A5%A8/"/>
    <url>/2022/03/12/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3.%E6%89%93%E5%8A%AB%E5%92%8C%E8%82%A1%E7%A5%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h4 id="打家劫舍">打家劫舍</h4><p>打劫问题就是注意维护选择当前点的状态和不选择当前点的状态即可。</p><h4 id="股票">股票</h4><p>其实贪心挺好用，但是这里可以考虑学学动态规划版本，用于对属性动态规划。</p><h3 id="example">Example</h3><h4 id="打家劫舍-1">打家劫舍</h4><p><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a> 还是比较基础，主要需要想明白动态规划转移该如何进行即可。</p><p>很自然的，因为不能选择两间紧挨着的房屋行动，所以考虑的情况一般都是隔一间行动，就可以知道一个状态必然会与 <code>dp[i-2] + nums[i]</code> 即直接跳过一间进行操作有关，但是如果仅仅这么操作并不能够完成处理子问题的需求，比如下面的那种情况：</p><table><thead><tr class="header"><th><code>nums[]</code></th><th>1</th><th>1</th><th>3</th><th>1</th><th>1</th><th>9</th><th>1</th><th>1</th></tr></thead><tbody><tr class="odd"><td><code>dp[]</code></td><td>1</td><td>1</td><td>4</td><td>4</td><td>4+1=5</td><td>4+9=13</td><td>...</td><td>...</td></tr></tbody></table><p>可以看出，在 i=3 时，很显然最优策略是选择 i=0, i=2 的方案，即其实根本没有选择要对这个位置操作，那么我们就可以得知另一个可行状态：<code>dp[i-1]</code>，即这一格不得行，不如直接多跳一格。 于是就有了 <code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code> 的逻辑。 剩下的部分就很简单啦！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">2</span>] + nums[i], dp[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a> 变成环形的了，但是同理。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> Math.max(subrob(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">2</span>), subrob(nums, <span class="hljs-number">1</span>, nums.length-<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subrob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-comment">// x = dp[i-2], y = dp[i-1]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, z = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            y = z;  <span class="hljs-comment">// same as y = dp[i-1]</span><br>            z = Math.max(y, x + nums[i]);<br>            x = y;  <span class="hljs-comment">// same as x = dp[i-2]</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> z;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a> <del>真能偷啊，偷到二叉树来了，原本想一次遍历的，结果被狠狠地整蛊到了</del> 思路：如果选了一个点，那么它的左右就不能选了，得选择左右节点的未选择左右节点的部分。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = subrob(root);<br>        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] subrob(TreeNode root) &#123;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-type">int</span>[] left = subrob(root.left);<br>        <span class="hljs-type">int</span>[] right = subrob(root.right);<br><br>        <span class="hljs-comment">// 不选择当前点</span><br>        res[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 选择当前点</span><br>        res[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="股票-1">股票</h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a> 首先来一个经典贪心： 直接取最大区间利润！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            low = low &lt; price ? low : price;<br>            res = Math.max(res, price-low);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a> 虽然贪心很方便，但是这次是动态规划版。 因为只对一只股票操作，而且状态是按照时间（一天）为单位而变化的，所以可以只记录当天和前一天，动态规划数组可以只开两行！ 同样的，一天的操作只有卖出和持有，动态规划数组只开两列。用 0 表示持有，用 1 表示不持有! <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], prices[i] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(prices.length-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a> 这个好复杂…… 要不断记录每天的状态，还要进行操作更新。 状态： <code>dp[0]</code>: Do nothing. <code>dp[1]</code>: 第一次买入 <code>dp[2]</code>: 第一次卖出 <code>dp[3]</code>: 第二次买入 <code>dp[4]</code>: 第二次卖出 直接按顺序操作，保证了就算是什么都不做也能够保存状态到 <code>dp[4]</code> 中。 假如最优是什么都不买，那么 <code>dp[1]</code> 和 <code>dp[3]</code> 将会保持一个始终小于的状态，<code>dp[2]</code> 和 <code>dp[3]</code> 也一直保持为零。</p><p>假如最优是只操作一次，那么必然是在一个低价买入，一个高价卖出。那么 <code>dp[2]</code> 必然是保持了一个 <strong>卖出 - 买入</strong> 的差值最大的状态，而且之前也没有能够进行获利，后续也无法满足再有一次能够收取利润的状态，即为：股价一路下跌，只涨了一次，之后又是一路下跌的状态！那么，对变量进行一个命名吧！规定：</p><p><span class="math inline">\(price_{min}\)</span> 股票一开始就下跌的最低点，也是由跌转涨的转折点； <span class="math inline">\(price_{max}\)</span> 股票唯一一次上涨的最高的，也是由涨转跌的转折点；</p><p>所以无论如何，<code>dp[3]</code> 只能为 <span class="math inline">\(price_{max} - price_{min} - price_{下跌}\)</span> 这一状态下，能取到的只能在最后一个点。</p><p>（不可能为初值，因为如果初值是最大值的情况下： <span class="math inline">\(price_{begin} = price_{min}\)</span>，此时 <span class="math inline">\(dp[3] = -price_{min}\)</span>， 在最后一个点有： <span class="math inline">\(price_{max} - price_{min} - price_{end} \\ = (price_{max} - price_{end}) - price_{begin}\)</span> 它如果要取最小值，就得有 <span class="math inline">\(price{end} = price_{max}\)</span> ， 也就是说，就算它的结果是初值，它也和最后一个点的值相同），所以 <code>dp[4]</code> 就能够忠诚地记录下 <span class="math inline">\(dp[3] + price = dp[2] - price + price = dp[2]\)</span> 的值。</p><p>如果是操作了两次，分析过程类似，暂时不赘述了。 （第一次进行买入卖出操作时的初值为 0，之后的初值为前面的买入卖出操作的最大值） 结果代码写出来那么简洁哇... <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>        dp[<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>] - price);<br>            dp[<span class="hljs-number">2</span>] = Math.max(dp[<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>] + price);<br>            dp[<span class="hljs-number">3</span>] = Math.max(dp[<span class="hljs-number">3</span>], dp[<span class="hljs-number">2</span>] - price);<br>            dp[<span class="hljs-number">4</span>] = Math.max(dp[<span class="hljs-number">4</span>], dp[<span class="hljs-number">3</span>] + price);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a> 这次是 k 笔交易了😨😨😨 其实可以把上面的那一题当成 k = 2 把这个泛化一下就好了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ (k &lt;&lt; <span class="hljs-number">1</span>)];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i += <span class="hljs-number">2</span>) &#123;<br>            dp[i] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>], -price);<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>] + price);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; dp.length; i += <span class="hljs-number">2</span>) &#123;<br>                dp[i] = Math.max(dp[i], dp[i-<span class="hljs-number">1</span>] - price);<br>                dp[i+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>], dp[i] + price);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a> 冷冻期都来了... 其实吧还是处理状态的问题…… 一般来说有三种操作——卖出、等待好价和有股（包括昨日买入和啥都没做单纯抱着股票等着卖）。设为 0, 1, 2。 |yesterday|today| |-|-| |卖出|冷冻| |等待好价|买入（变成有股） / 等待| |有股等卖|卖出 / 继续有股| 所以有状态转移： <span class="math inline">\(dp[i][0] = do[i-1][2] + price \\ dp[i][1] = max(dp[i-1][1], do[i-1][0]) \\ dp[i][2] = max(dp[i-1][1] - price, dp[i-1][2])\)</span> 接下来实现就可以了，不过最后的时候需要考虑一下在最后几天的时候究竟是卖出去赚，还是早就卖出去了才是赚的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp0</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp1</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">2</span>] + price;<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], tmp0);<br>            dp[<span class="hljs-number">2</span>] = Math.max(tmp1 - price, dp[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a> 基本操作加上一个减去手续费即可了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] - price);<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>] + price - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 但是怎么比贪心用时超了这么多... 对比贪心的话，发现应该是操作太多了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>] + fee;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : prices) &#123;<br>            <span class="hljs-keyword">if</span> (p + fee &lt; buy) &#123;<br>                buy = p + fee;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &gt; buy)&#123;<br>                sum += p - buy;<br>                buy = p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><h4 id="打家劫舍-2">打家劫舍</h4><p>打劫问题的思路就在于把握住两状态：<strong>选择当前点</strong>和<strong>不选择当前点</strong>。 按照这样的逻辑进行状态维护就可以了。</p><h4 id="股票-2">股票</h4><p>主要要知道需要维护很多很多状态和知道状态要怎么变化。 很多时候最好是把状态都列出来，宁可多列得详细一些，最后在合并化简，也不要直接简化。。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part10 动态规划 背包</title>
    <link href="/2022/03/10/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2.%E8%83%8C%E5%8C%85/"/>
    <url>/2022/03/10/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2.%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>背包问题是一种比较经典的动态规划： #### 0-1 背包问题 首先是 <strong>01 背包问题</strong>，只有在与不在状态，它的描述如下： 已知第 <span class="math inline">\(i\)</span> 个物品的重量 <span class="math inline">\(w_i\)</span> ，价值 <span class="math inline">\(v_i\)</span> ，以及背包的总容量 <span class="math inline">\(W\)</span>。 假设 DP 状态 <span class="math inline">\(f_{i,j}\)</span> 为：放入 <span class="math inline">\(i\)</span> 个物品的情况下，容量为 <span class="math inline">\(j\)</span> 的背包能够达到的最大总价值。 那么状态转移逻辑如何呢？ 如果已经处理了 <span class="math inline">\(i-1\)</span> 个物品的状态，当前需要处理第 <span class="math inline">\(i\)</span> 个物品 如果这个物品不放入背包，价值不变，容量不变，状态为 <span class="math inline">\(f_{i-1,j}\)</span>； 如果将它放入背包，价值增加，容量减少，状态变为 <span class="math inline">\(f_{i-1,j-w_i} + v_i\)</span>。 所以状态转移方程为： <span class="math inline">\(f_{i,j} = max(f_{i-1,j}, f_{i-1,j-w_i}+v_i)\)</span> <strong>大部分的背包问题都是基于此方程</strong> 当然了，这个使用到了二维数组，实际上会消耗比较大的空间，注意到上面对于 <span class="math inline">\(i\)</span> 的变化只与 <span class="math inline">\(i-1\)</span> 相关，所以可以考虑仅利用 <span class="math inline">\(j\)</span> 进行处理，这样，状态转移方程为： <span class="math inline">\(f_j = max(f_{j}, f_{j-w_i} + v_i)\)</span> 但是，关于核心代码仍有一点需要注意： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; W - w[i]; l++)<br>        f[l + w[i]] = Math.max(f[l] + v[i], f[l + w[i]])<br><span class="hljs-comment">// 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l + w[i]]); 简化而来</span><br></code></pre></td></tr></table></figure> 上面的的代码在枚举顺序出了问题， 对于当前处理物品 <span class="math inline">\(i\)</span> 和状态 <span class="math inline">\(f_{i,j}\)</span> ，在 <span class="math inline">\(j \geqslant w_i\)</span> 时，<span class="math inline">\(f_{i,j}\)</span> 是会被 <span class="math inline">\(f_{i,j-w_i}\)</span> 所影响的。按照这样的顺序遍历，物品 <span class="math inline">\(i\)</span> 可以多次被放入背包，与题意不符。（但是是完全背包问题的解法） 为了避免这种情况发生，我们可以改变枚举的顺序，从 <span class="math inline">\(W\)</span> 枚举到 <span class="math inline">\(w_i\)</span> ，这样就不会出现上述的错误，因为 <span class="math inline">\(f_{i,j}\)</span> 总是在 <span class="math inline">\(f_{i,j-w_i}\)</span> 前被更新。 实际上应为： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量，更新</span><br>        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 先确定这次操作的物品，然后再用它对 dp 状态进行更新。 按照从后往前的顺序进行遍历，保证状态不会和之前状态重合，这样每种物品就只取一次了。</p><h4 id="完全背包问题">完全背包问题</h4><p>完全背包问题和 0-1 背包问题的最大区别就是完全背包问题的物品<strong>可以放无限次</strong>。 核心代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="多重背包问题">多重背包问题</h4><p>把它摊开变成 0-1 背包的版本吧</p><h3 id="example">Example</h3><h4 id="背包问题">0-1 背包问题</h4><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a> 没想到吧，这个居然是背包。 既然分成等和子集，说明每个子集的和都是 sum/2 ，既然如此，题目就变成了与01背包问题类似的放入元素的处理方法。 因为01背包问题的要求是：选取物品总和不能超过背包总容量，这里要求是所求物品总和恰好为数组和的一半，那么就把 sum/2 当作背包体积。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= num; j--) &#123;<br>                dp[j] |= dp[j-num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a> 与分割等和子集相似，既然要尽可能的互相砸石头让最后留下来的最小，那么应该尽可能地将石头分成重量大小几乎相等的两堆，就转变成分割等和子集问题了，用类似的解法就可以。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stone : stones) &#123;<br>            sum += stone;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stone : stones) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stone; j--) &#123;<br>                dp[j] = Math.max(dp[j], dp[j-stone] + stone);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - (dp[target] &lt;&lt; <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a> 关键在于明白如何将其转为背包。 因为对于目标和的实现来说，可以想为将其分解为 <code>left</code> 和 <code>right</code> 两个子集。 那么对于能够达成结果的情况来说，有： <span class="math inline">\(left - right = target\)</span>（等于是认为取正号的在<code>left</code>里，取负号的在<code>right</code>里） 又</p><p><span class="math inline">\(\because left + right = sum\)</span></p><p><span class="math inline">\(\therefore left - (sum - left) = target \rightarrow 2 * left = target + sum\)</span></p><p><span class="math inline">\(\therefore left = (sum + target) / 2\)</span></p><p>这不仅表现了该如何求解 <code>left</code> ，并且提供了一个判断是否有解的方式。 于是可以就构造成背包问题了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            sum += num;<br>        <span class="hljs-keyword">if</span> (Math.abs(target) &gt; sum || (target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagSize</span> <span class="hljs-operator">=</span> (target + sum) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= num; j--) &#123;<br>                dp[j] += dp[j-num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a> 其实可以把 0 和 1 的计数当作是他们的 weight ，字符串本身的个数相当于物品的价值。 这样就转成了01背包问题。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oneCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">zeroCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">char</span>[] chs = str.toCharArray();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : chs) &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    oneCount++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    zeroCount++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= zeroCount; i--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= oneCount; j--) &#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i-zeroCount][j - oneCount] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="完全背包问题-1">完全背包问题</h4><p><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a> 用 <code>dp[j]</code> 来表示合成 j 有多少种方法，j 即为容量。 初始化的 <code>dp[0]</code> 当然只有一种组合。 因为可以重复，所以需要正向遍历。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coin; j &lt;= amount; j++) &#123;<br>                dp[j] += dp[j-coin];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a> &gt; 请注意，顺序不同的序列被视作不同的组合。</p><p>这不是排列？ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= num)<br>                    dp[j] += dp[j - num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a> 这也是背包哇，考虑成跳到楼顶有几种方法。 原型比较基础，但是可以进阶成为一个完全背包问题。可以考虑改成每次爬 <span class="math inline">\([1, m]\)</span> 级台阶的进阶版本。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; weight.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= weight[j]) dp[i] += dp[i - weight[j]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a> 显然对于满足最优子结构的转移方程应为： <span class="math inline">\(F(j) = \min \limits_{j=0...n-1}(F(i-c_j) + 1)\)</span>（自底向上）</p><p>或者是自上而下版本：</p><p><span class="math inline">\(F(S) = \min \limits_{i=0...n-1}F(S-c_i) + 1, subject to S-c_i \geqslant 0 \\ F(S) = 0, S = 0 \\ F(S) = -1, n = 0\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coin; j &lt;= amount; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j-coin] != Integer.MAX_VALUE)<br>                    dp[j] = Math.min(dp[j], dp[j-coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a> 利用 <code>i*i</code> 达成平方数的选择，别的就和上面一样。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n/<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> i * i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> square; j &lt;= n; j++) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - square]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n]; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a> 很想用回溯对吧。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] valid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        valid[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (wordDict.contains(s.substring(j,i)) &amp;&amp; valid[j]) &#123;<br>                    valid[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><!-- #### 多重背包问题 --><h3 id="conclusion">Conclusion</h3><p>背包问题很多时候不会以背包的样子出现，需要稍微绕几个弯，将其构造成背包的样子。 再看看其实说背包也不背包，但是很动态规划，回想起来还是应该明晰本质的动态规划问题！</p><h4 id="递推结构">递推结构</h4><p>关于背包，有几种操作： - 背包装满的最大价值 递推公式<span class="math inline">\(dp(x) = max(dp(x), dp(x-weight_j) + value_j)\)</span> <code>dp[i][j] = Math.max(dp[i][j], dp[i-zeroCount][j - oneCount] + 1);</code> <a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></p><ul><li><p>能否装满背包 递推公式<span class="math inline">\(dp(x) = max(dp(x), dp(x-weight_j) + weight_j)\)</span> <code>dp[j] = Math.max(dp[j], dp[j-stone] + stone);</code> <a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></p></li><li><p>装满背包有几种方法 递推公式<span class="math inline">\(dp(x) = dp(x) + dp(j)\)</span> <code>dp[j] += dp[j-num];</code> <a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></p></li><li><p>装满背包的最小物品数 递推公式<span class="math inline">\(dp(x) = min(dp(x), dp(x-weight_j) + 1)\)</span> <code>dp[j] = Math.min(dp[j], dp[j-coin] + 1);</code> <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></p></li></ul><h4 id="遍历顺序">遍历顺序</h4><p>对于 0-1 背包问题，注意使用一维 dp 数组时，应先对物品进行遍历，再对容量进行遍历 对于完全背包问题：顺序本质上没有影响，但是： <strong>求组合时，可以外层遍历物品，内层遍历容量</strong> <strong>求排列时，应该外层遍历背包，内层遍历物品</strong>（保证物品可以自由选择）</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part10 动态规划 基础</title>
    <link href="/2022/03/09/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1.%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/09/Algorithm/Part10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h4 id="简介">简介</h4><p>动态规划，即 DP ，核心思路是根据重叠的子问题，由上一个状态推导下一个状态。 由此区别于贪心算法——通过达成局部最优解构造全局最优解，动态规划是将原问题分解成子问题，从而解决问题的方法。 #### 步骤 - 确定递推公式关系 - 确定如何初始化 - 确定遍历顺序</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">斐波那契数</a> 典，是从状态转移到子问题分解都涉及到的经典了。 状态 <span class="math display">\[f(x) = \left\{\begin{array}{l}F(0) = 0, F(1) = 1 \\F(n) = F(n-1) + F(n-2), (n &gt; 1)\end{array}\right.\]</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 甚至可以把状态压缩： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>] = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a> 到达当前状态可以是比当前状态 低一层 + 爬一阶 或者是当前状态的 低两层 + 爬两阶 也就是说，有两个子状态可以到达当前状态，那么到达当前状态可以有两种子状态的次数和。 即<span class="math display">\[dp(n) = dp(n-1) + dp(n-2)\]</span>，如果你要问：为什么就是取它们的和就好了，而不用再做多处理呢？ 那么假设当前位于第 n 层，那么在第 n-1 层，有 dp(n-1) 种方法到达，那么你再走一层到达第 n 层，实质上也还是这 dp(n-1) 种路径达成的，并没有增加别的，所以 n-2 的解释同理。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>] = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a> 用 <code>int[] dp</code> 记录在某层楼梯并且向上爬的花费。 能够到达当前位置 n 的最小值自然是 <span class="math display">\[min(dp[n-1], dp[n-2])\]</span> ，再加上当前的 cost 即为当前的花费。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = Math.min(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]) + cost[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[n-<span class="hljs-number">1</span>], dp[n-<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a> 因为每次可以是从上方的格子到达，也可是从左方的格子到达，所以能够到达该格的路径自然是这两个方式之和。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 也可以用一维数组，毕竟也是一层一层来的。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径II</a> 其实就是多了个障碍物，也不太影响了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java">classSolution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a> &gt; 其实可以从1遍历j，然后有两种渠道得到dp[i]. &gt; 一个是j * (i - j) 直接相乘。 &gt; 一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i-<span class="hljs-number">1</span>; j++) &#123;<br>                dp[i] = Math.max(dp[i], Math.max(j * (i-j), dp[i-j] * j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a> 对于一棵新的 n 节点数，可以想象其是由一个节点加上左右子树构成 那么这棵新数的根节点可以由 1 ~ n 分别构成。 假设根节点为 x ，则有： 其左子树最多只能有 x-1 个节点（只有 x-1 个数小于 x ），那么右子树节点数则是对应之差。 而且节点数为 y 的排列方式由 dp[y] 记录。 所以即可使用动态规划解决问题。 所以只需要遍历左右节点的情况即可。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i-<span class="hljs-number">1</span>; j++) &#123;<br>                dp[i] += dp[i-j-<span class="hljs-number">1</span>] * dp[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>动态规划的核心思路还是拆分组合，想明白了就简单了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part9 贪心 下</title>
    <link href="/2022/03/08/Algorithm/Part9-%E8%B4%AA%E5%BF%83-%E4%B8%8B/"/>
    <url>/2022/03/08/Algorithm/Part9-%E8%B4%AA%E5%BF%83-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零</a> 在作业里写过的一道题。 局部最优就是剩下的钱操作最灵活，即5元留得最多，所以尽可能地用10元找零就是最优。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br>        <span class="hljs-keyword">if</span> (bills[<span class="hljs-number">0</span>] != <span class="hljs-number">5</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ten</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) &#123;<br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>                five++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                ten++;<br>                five--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">20</span>) &#123;<br>                five--;<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    ten--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    five -= <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (five &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a> 确定： 对于一个 <code>people</code>——<code>o</code> 有： 如果 <code>o[0]</code> 即身高相同的情况下， <code>o[1]</code> 更小的靠前，表示着前面有更少相同身高或更高身高的在前。 同理 <code>o[1]</code> 即前排有身高更高或者相同的人排在他前面的数目相同的情况下， <code>o[0]</code> 更小的靠前，因为假设 <code>o[1]</code> 都为 0 ，那么身高更高的自然应该靠前。 保持这样的性质，我们如何构造局部最优解呢？ 其实一直保持这样的性质就是局部最优，一路保持就是全局最优！ 接下来的任务就是如何实现保持这样的性质进行操作了！ 如果直接模拟思路进行操作的话会比较麻烦吧…… 首先考虑如何设计排序： 如果按照身高排序，并且相同身高的按照前排数排序，可以保证： 直接塞下去没问题！ 而且直接按照 k 塞下去，也能够保持这样的性质！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][<span class="hljs-number">2</span>];<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        Arrays.sort(people, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] peo : people) &#123;<br>            res.add(peo[<span class="hljs-number">1</span>], peo);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] cur : res) &#123;<br>            ans[i++] = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a> 局部最优： 在当前情况下，继续往后找出箭的位置，这个位置能够保证打到下一个气球的左边界同时也能够击中当前气球最优！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-keyword">if</span> (points.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(points, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                res++; <span class="hljs-comment">// 位置越界打不到</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>],points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a> 按照右边界排序，每次扩张尽可能地找到符合条件的右边界最小的区间加入，如果不符合（目前处理的区间的起点在当前右边界左边，则将其移除，计数） 这样保证每次的操作下，剩下的空间都是尽可能多的，即每次操作剩下的符合条件的区间就多，需要移除的就少。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">1</span>], o2[<span class="hljs-number">1</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (end &lt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a> 说贪心其实也不太贪心。 如果是按照贪心的思路分析的话，也许圈出最后出现位置是贪心吧。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>            last[chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cut</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preidx</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>            cut = Math.max(cut, last[chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == cut) &#123;<br>                ans.add(cut - preidx);<br>                preidx = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a> 找最靠后的尾巴，划分范围！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &lt;= end) &#123;<br>                end = Math.max(end, interval[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;);<br>                end = interval[<span class="hljs-number">1</span>];<br>                start = interval[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;);<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">单调递增的数字</a> 好像没有很贪心…… 它的思路是追踪数组的形式，找寻最长的递增段，出现问题后，从最长递增段的末尾-1，之后填上 '9' 。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[] chs = Integer.toString(n, <span class="hljs-number">10</span>).toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (chs[i] &gt; chs[i+<span class="hljs-number">1</span>]) &#123;<br>                err = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chs[i] &lt; chs[i+<span class="hljs-number">1</span>]) &#123;<br>                start = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            chs[start] -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start+<span class="hljs-number">1</span>; i &lt; chs.length; i++) &#123;<br>                chs[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        StringBuilder res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : chs) &#123;<br>            res.append(ch);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(res.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a> 有点像最大连续子数组，但其实应该用动态规划，但是贪心也挺好理解。 <strong>注意：不要用一个自然体会时间流逝的人的角度思考，要用一个已经预知了整个股市发展的角度思考</strong> 比如：<code>buy</code> 并不是真的买了，而是记录一下这个时候买入的价格。 对于贪心来说，局部的最好收益就是在一个低价格买入，然后在高价格卖出。 所以记录低价，然后等待高价。 而且一个比较巧妙的处理方法是 <code>sum += p - buy</code> 实际上隐含了 <code>sum += p_j - p_i + (p_i - buy_before)</code> 还是处理了一个 <code>sum += p - buy</code>，这里的 <code>p</code> 是 <code>(p &gt; buy)</code> 即大于之前的卖出价格 (buy = p)。 即实现了一个更高价卖出的结果。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>] + fee;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : prices) &#123;<br>            <span class="hljs-keyword">if</span> (p + fee &lt; buy) &#123;<br>                buy = p + fee;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &gt; buy)&#123;<br>                sum += p - buy;<br>                buy = p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">监控二叉树</a> 如果叶子节点上放了摄像头，那么就会浪费了它的下层。 比较合理的思路是： 如果它的左右孩子节点至少有一个没有被覆盖到，那不行，它必须有一个摄像头，返回状态：有摄像头（2）。 那么剩下来的情况里，左右节点要么是被覆盖到，要么就有摄像头。 但是要对这种情况解析： 如果是有一个有摄像头，那么就不需要放置摄像头，返回状态：覆盖（1）。 否则就是左右两边都没有摄像头，都只是覆盖，那么节点本体如果再装摄像头，就会导致重复，造成浪费，所以就当它没被覆盖，返回状态：未覆盖（0）。 局部最优：当前状况下处理的结果是用摄像头最少的。 全局最优：总体使用的是最少的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (travsal(root) == <span class="hljs-number">0</span>) &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">travsal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> travsal(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> travsal(root.right);<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> || right == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>贪心贪心，何为贪心？ 有时候会觉得，这么简单居然是贪心？ 有时候又觉得，这么复杂要怎么贪心？ 尽力构造局部最优，并且确定每一步保持这个局部最优最后能够达到全局最优！ 其实有时候有点马后炮的意思，因为给出的是已知的，并不是盲目地进行决策，可以在一个更高的角度指指点点，想象一下那个决策者的操作。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part9 贪心 上</title>
    <link href="/2022/03/07/Algorithm/Part9-%E8%B4%AA%E5%BF%83-%E4%B8%8A/"/>
    <url>/2022/03/07/Algorithm/Part9-%E8%B4%AA%E5%BF%83-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>贪心法的主要思路还是找寻局部最优解吧，要求有最优子结构，子问题的最优解能够推到问题的最终解。 但是呢，是否是真的最优解需要证明。 而且，重要的是，贪心算法不仅需要优化子结构，同时要保证大问题只依赖于一个子问题。 贪心的证明的话，一般用归纳法吧……</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a> P.S. 这个应该是在算法课的考试里写过的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length &amp;&amp; count &lt; g.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (g[count] &lt;= s[i]) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a> 这题还挺神秘的…… 如何判断它的摆动呢？ 既然有摆动，那么就不是单调的！ 留一个prediff记录单调性！ 再和当前的单调性比较，如果变化了就说明摆动了！ 全局的摆动肯定会有局部的摆动参与， 描述摆动的话可以用峰值处理！ 因为如果假设不用峰值，在爬坡或下坡的段落选择点，要想得到摆动还是得再另一种单调性的坡度上选取，不如直接用峰值代替！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curdiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prediff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            curdiff = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> ((curdiff &gt; <span class="hljs-number">0</span> &amp;&amp; prediff &lt;= <span class="hljs-number">0</span>) || (curdiff &lt; <span class="hljs-number">0</span> &amp;&amp; prediff &gt;= <span class="hljs-number">0</span>)) &#123;<br>                count++;<br>                prediff = curdiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a> 直接一路走！记录局部最优解（当前最大值） 毕竟是连续子数组<sub>（如果不连续的话全取正数倒更简单了）</sub>，所以全局最优起码在局部肯定是最优，最优的局部就是全局！ 不过按照贪心的局部最优来理解的话其实是这样的： 对于一串连续子数组来说，只要当前连续的部分不是负数，那么它就是有用的！而且不用怀疑，起点的设定一定是正的，不用考虑挪动头部什么的！既然它是正的有用的，它就是局部最优！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            cur += num;<br>            <span class="hljs-keyword">if</span> (cur &gt; res) &#123;<br>                res = cur;<br>            &#125;<br>            cur = (cur &lt;= <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a> 思考：局部最优解就是能够获取利润的一次交易单元（第二天减第一天的价格即为收益） 既然收益为正，就是最优的！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            res += Math.max(prices[i] - prices[i-<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a> 局部跳得最远就是这个时候的最优解。 全局最优解应该是一步一步的范围内跳过来的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curmax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= curmax; i++) &#123;<br>            curmax = Math.max(nums[i] + i, curmax);<br>            <span class="hljs-keyword">if</span> (curmax &gt;= nums.length-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a> 要求最少步数！ 那么可以知道，当前格子步数覆盖范围内再跳，局部最优解一定是跳到那个范围内能够跳到最远的格子上！ 而且这么跳一定能到全局最优！ 那么怎么实现呢？我如何知道它是最大值呢？ 反正要遍历到当前能够覆盖到的格子才能知道有最大值吧！ 那么就是走完 curmax 后更新最大值好了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span> || nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curmax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= nums.length; i++) &#123;<br>            tmp = Math.max(tmp, nums[i] + i);<br>            <span class="hljs-keyword">if</span> (tmp &gt;= nums.length-<span class="hljs-number">1</span>) &#123;<br>                count++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;               <br>            <span class="hljs-keyword">if</span> (i == curmax) &#123;<br>                curmax = tmp;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">K 次取反后最大化的数组和</a> 这还挺贪心的，局部最优就是使得当前总和最大的操作，每次操作都是做到当前总和最大，那么就是全局最优了！ 但是可以选择重复的？！ 当然还是用绝对值排序比较好。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                nums[i] = -nums[i];<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)<br>            Arrays.sort(nums);<br>        <br>        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) nums[<span class="hljs-number">0</span>] *= -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            sum += num;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a> <code>totalSum</code> 的意义：保证能够顺利跑完。 <code>curSum</code> 的意义：类似 <a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a> 的思路 &gt; 对于一串连续子数组来说，只要当前连续的部分不是负数，那么它就是有用的！</p><p>对这里也是如此。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;<br>                start = i + <span class="hljs-number">1</span>;<br>                curSum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a> 挺神奇的，两次贪心。 &gt;- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。 &gt;- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candyVec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        candyVec[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; ratings.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])<br>                candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                candyVec[i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ratings.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = Math.max(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candy : candyVec)<br>            result += candy;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>感觉贪心的内容挺杂。得慢慢来，要学会想清楚什么是局部最优解。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part8 回溯 下</title>
    <link href="/2022/03/05/Algorithm/Part8-%E5%9B%9E%E6%BA%AF-%E4%B8%8B/"/>
    <url>/2022/03/05/Algorithm/Part8-%E5%9B%9E%E6%BA%AF-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>承接前篇，在前篇的 <a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a> 里算是初步接触到了去重，这里对去重相关的内容进行了一次强化练习，做完就明白了！</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/subsets/">子集</a> 简简单单解决 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt; nums.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            cur.add(nums[i]);<br>            backtracking(nums, i+<span class="hljs-number">1</span>);<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/">子集 II</a> 思路和前面的一题差不多，为了去重需要进行排序。 利用排序的结果移动 i ，跳过重复的元素。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt; nums.length)<br>            <span class="hljs-keyword">return</span>;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            cur.add(nums[i]);<br>            backtracking(nums, i+<span class="hljs-number">1</span>);<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a> 从给的例子来看是不需要连续的，但是需要按照顺序。 注意形如 <code>[7,4,6,7,7]</code> 的序列 如果仅仅是比较连续的相同元素的方法在这里并不适用（只适用于排序过的序列）。 所以这里需要引入标记数组 <code>boolean[] used</code> 进行去重，比如说 <code>7</code> 在第一个位置用过了，那么继续向后处理 <code>nums</code> 时的会遇到的后面的元素 <code>7</code> 就是已经用过的不会再重新放在第一个位置里操作，就达到了去重的结果。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt; nums.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (cur.size() &gt; <span class="hljs-number">1</span>)<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">201</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((!cur.isEmpty() &amp;&amp; nums[i] &lt; cur.get(cur.size()-<span class="hljs-number">1</span>)) || used[nums[i] + <span class="hljs-number">100</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            cur.add(nums[i]);<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i+<span class="hljs-number">1</span>);<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/permutations/">全排列</a> 直接用 <code>boolean[] used</code> 进行全局去重挺方便的。(是不是想起了数据结构课上教过dfs的标记数组呀) 或者直接使用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (cur.contains(num))<br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure> 也挺合适的。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">21</span>];<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur.size() == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (used[num + <span class="hljs-number">10</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            cur.add(num);<br>            used[num + <span class="hljs-number">10</span>] = <span class="hljs-literal">true</span>;<br>            backtracking(nums);<br>            used[num + <span class="hljs-number">10</span>] = <span class="hljs-literal">false</span>;<br>            cur.remove(cur.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a> 两层去重，一个全局去重，一个层内去重。 全局：确保同一位置的元素不会使用重复，主要作用于全排列的形成，用于正常的选择元素进行排列，因为这里有重复的元素，所以其实不方便使用 <code>contains</code> 。 层内：确保当前填充不会重复，比如 <code>[3, 1, 1, 2]</code> 的情况： 设已经填入一个 <code>3</code> 然后再填入了一个 <code>1</code> 这时标记在局部里已经使用过，保证将 <code>1</code> 吐出来后不会再装同样的内容进去。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur.size() == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span>[] localused = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">21</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i] || localused[nums[i] + <span class="hljs-number">10</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            cur.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            localused[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-literal">true</span>;<br>            backtracking(nums);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a> 还蛮复杂的…… 首先确定一些事实： - 每张票必须用且只能用一次 -&gt; 使用 <code>boolean[] used</code> 标记。 - 出发点都是 'JFK' -&gt; 直接把它加进去。 - 按字典排序返回最小的行程组合 -&gt; 设置特定排序 - 设置回溯的返回值为 boolean 作为退出的辅助 当回溯写吧，注意这里使用的排序功能。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[tickets.size()];<br>        ans.add(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        tickets.sort(Comparator.comparing(o -&gt; o.get(<span class="hljs-number">1</span>)));<br>        backtracking(tickets);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ans.size() == tickets.size() + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tickets.size(); i++) &#123;<br>            List&lt;String&gt; ticket = tickets.get(i);<br>            <span class="hljs-keyword">if</span> (!ticket.get(<span class="hljs-number">0</span>).equals(ans.get(ans.size()-<span class="hljs-number">1</span>)) || used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ticket.get(<span class="hljs-number">1</span>)));<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (backtracking(tickets)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            used[i] = <span class="hljs-literal">false</span>;<br>            ans.remove(ans.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a> 很经典的回溯思路。 主要是看着吓人，实际上处理 <code>isValid()</code> 就可以了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[][] chessboard;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;<br>            Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        backtracking(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (!isValid(row, col, n))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                builder.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            builder.setCharAt(col, <span class="hljs-string">&#x27;Q&#x27;</span>);<br>            chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            cur.add(String.valueOf(builder));<br>            backtracking(n, row+<span class="hljs-number">1</span>);<br>            chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// check col</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// check /</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>, j = col+<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// check \</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>, j = col-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a> 这个就不仅仅是设计 <code>isValid()</code> 逻辑那么简单啦。 仔细想想思路其实也差不多，但是主要注意退出的条件。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        backtracking(board);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++) &#123;<br>                <span class="hljs-keyword">if</span> (board[row][col] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123;<br>                    <span class="hljs-keyword">if</span> (!isValid(board, row, col, ch))<br>                        <span class="hljs-keyword">continue</span>;<br>                    board[row][col] = ch;<br>                    <span class="hljs-keyword">if</span> (backtracking(board))<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val)</span> &#123;<br>        <span class="hljs-comment">// check row.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[row][i] == val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// check col.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][col] == val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// check block.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt; x+<span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> y; j &lt; y+<span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>这里是对回溯的进一步练习，涉及到的内容包括一些去重，条件判断等。 主要需要做到将回溯与判断条件相结合！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part8 回溯 上</title>
    <link href="/2022/03/04/Algorithm/Part8-%E5%9B%9E%E6%BA%AF-%E4%B8%8A/"/>
    <url>/2022/03/04/Algorithm/Part8-%E5%9B%9E%E6%BA%AF-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h4 id="什么是回溯法">什么是回溯法？</h4><p>回溯法常常用于搜索 (BFS 和 DFS) 的方法。 它的本质可以用 <strong>走不通就回头</strong> 来概括。 它其实和 DFS 关系应该更密切些。 相当于一路走到黑，然后不通就恢复状态，继续走（这就是深度遍历嘛）</p><h4 id="回溯法的思路">回溯法的思路</h4><p>利用 for 循环进行当前位置的横向遍历 利用 递归 进行纵向遍历</p><h4 id="能够解决的问题">能够解决的问题</h4><ul><li>组合问题： N 个数里按照一定顺序找出 k 个数的集合</li><li>切割问题：一个字符串按照一定规则有多少种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>排列问题： N 个数按一定顺序全排列</li><li>期盼问题： N 皇后，或者是数独</li></ul><h4 id="模板">模板</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">backtracking</span>(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="examples">Examples</h3><a href="https://leetcode-cn.com/problems/combinations/">组合</a> 这个组合问题很有意思啊，主要是递归的用法很有用! 这里的选择方法还有一个优化的地方 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - cur.size()) + <span class="hljs-number">1</span>; i++)<br></code></pre></td></tr></table></figure> 它的想法是：因为最后剩下的需要选择的 <code>(k - cur.size())</code> 个元素分布在最后面，实际上最后需要这些元素的时候会选到的，所以前面不需要选它们了。<details><summary>参杂了一部分高中时期的回忆</summary> 在高中的时候就和同学讨论组合数的选取的方法，其实有点固定了 k-1 个数，然后再在后面的数字里一个一个选出来和前面的 k-1 个数组合的结果，其实这种方法应该挺适合用回溯的，但是这里的思路是递归回来，原来的思路是前往后选，可能是一种类似双指针的方法，不过这次用回溯就很合适了！</details><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    LinkedList&lt;Integer&gt; cur;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        backtracking(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur.size() == k) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - cur.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            cur.add(i);<br>            backtracking(n, k, i+<span class="hljs-number">1</span>);<br>            cur.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III</a> 和上面一样，就是加了一个判断，其实也还好。 通过 <code>sum</code> 和 <code>target</code> 判断是否需要加入组合里。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    LinkedList&lt;Integer&gt; cur;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> target;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        target = n;<br>        sum = <span class="hljs-number">0</span>;<br>        backtracking(k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur.size() == k) &#123;<br>            <span class="hljs-keyword">if</span> (sum == target) ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - cur.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            cur.add(i);<br>            sum += i;<br>            backtracking(k, i+<span class="hljs-number">1</span>);<br>            sum -= i;<br>            cur.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a> 基本上是一个思路 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] letterMap = &#123;<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;abc&quot;</span>,<br>            <span class="hljs-string">&quot;def&quot;</span>,<br>            <span class="hljs-string">&quot;ghi&quot;</span>,<br>            <span class="hljs-string">&quot;jkl&quot;</span>,<br>            <span class="hljs-string">&quot;mno&quot;</span>,<br>            <span class="hljs-string">&quot;pqrs&quot;</span>,<br>            <span class="hljs-string">&quot;tuv&quot;</span>,<br>            <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br><br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            ans.add(String.valueOf(builder));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> letterMap[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            builder.append(ch);<br>            backtracking(digits, index + <span class="hljs-number">1</span>);<br>            builder.deleteCharAt(index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        backtracking(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a> 这里与之前的那个 <a href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III</a> 不一样（这里不是指因为它给了一个生的数组需要先排序），它实际上主要的要求是数字可以重复，所以回溯的遍历过程不应该直接往后找，需要带上本体。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    List&lt;Integer&gt; cur;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;<br>            cur.add(candidates[i]);<br>            sum += candidates[i];<br>            backtracking(candidates, target, i);<br>            sum -= candidates[i];<br>            cur.remove(cur.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a> 去重是一项麻烦活，这里通过 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure> 保证了重复的元素只选第一次。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;<br>            cur.add(candidates[i]);<br>            sum += candidates[i];<br>            backtracking(candidates, target, i+<span class="hljs-number">1</span>);<br>            sum -= candidates[i];<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a> 还挺复杂的…… 考虑的内容： 回溯的终点？ 字符串走到终点即为回溯终点。 操作一些什么？ 比如当前 cur 存着了一些回文子串，剩下的字符串还没分割成子串的情况 那么该怎么割呢？ 对于一次操作来说， 需要注意的是串的起点吧，从起点开始，对一个字符串，不断地后移， 依次判断是否为回文串， 如果是，那么再把它起点 + 回文串长，继续找字串， 找完了，再退回来。 大概如此。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtrack(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= s.length()) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start+<span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">substr</span> <span class="hljs-operator">=</span> s.substring(start, i);<br>            <span class="hljs-keyword">if</span> (!isPalin(substr))<br>                <span class="hljs-keyword">continue</span>;<br>            cur.add(substr);<br>            backtrack(s, i);<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalin</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = s.length()-<span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-keyword">if</span> (chs[i] != chs[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原 IP 地址</a> 思路和上面其实差不多，都是分割字符串，加上一些判断。 并且在关键部位回溯。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">atEnd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.length() != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!atEnd)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (String str : cur) &#123;<br>                builder.append(str);<br>                builder.append(<span class="hljs-string">&quot;.&quot;</span>);<br>            &#125;<br>            builder.deleteCharAt(builder.length()-<span class="hljs-number">1</span>);<br>            ans.add(String.valueOf(builder));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start+<span class="hljs-number">1</span>; i &lt;= s.length() &amp;&amp; i &lt;= start + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">substr</span> <span class="hljs-operator">=</span> s.substring(start, i);<br>            <span class="hljs-keyword">if</span> (!isValid(substr))<br>                <span class="hljs-keyword">continue</span>;<br>            cnt++;<br>            cur.add(substr);<br>            atEnd = (i == s.length());<br>            backtracking(s, i);<br>            cnt--;<br>            cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>结果 组合总和 III 是最简单的。 关于回溯，主要需要想明白几个点： 1. 我该如何结束，并且存储成功结果/失败退出 （eg: 存够数了 / 目标值达到了 / 到终点了） 2. 我的循环内应该做什么 （eg: 判断子串是否合法） 3. 我该如何返回状态 （eg: 把之前加上去的东西删掉）</p><p><del>至此回溯的第一部分算是学习完毕，其实感觉还好，一开始莫名其妙的，就是懵懵懂懂直接上了，实际上写了一点就比较顺手了</del></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part7 二叉树 下</title>
    <link href="/2022/03/03/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-3.%E4%B8%8B/"/>
    <url>/2022/03/03/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-3.%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>这里涉及到的内容应该是一些二叉树的更进阶用法吧！</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a> 就是基础用法啦 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root.val &lt; val) <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        <span class="hljs-keyword">if</span> (root.val &gt; val) <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a> 已知给定了一颗二叉树，要求验证其是否为二叉搜索树 那么既然要验证，肯定要访问，所以说是遍历，正好数据结构课上也说过</p><blockquote><p>中序遍历二叉搜索树的结果是一个有序序列</p></blockquote><p>所以这里实现一个中序遍历即可，那么怎么确定这个有序序列的正确性呢？ 这里通过维护一个 prev 变量，在中序遍历(即访问)的时候确定和 prev 比较的结果即可。 同时，需要注意的是： <code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code> 这个范围 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= prev)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        prev = root.val;<br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a> 本质遍历，这里需要做的是维护一个存储最小值的 <code>minabs</code> 和前一个节点 <code>prev</code> 。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minabs</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">private</span> TreeNode prev;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        traversal(root);<br>        <span class="hljs-keyword">return</span> minabs;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traversal(root.left);<br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>            minabs = Math.min(minabs, root.val - prev.val);<br>        &#125;<br>        prev = root;<br>        traversal(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a> 依然是 维护变量 + 中序遍历 的思路进行。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> curCount;<br>    TreeNode prev;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) &#123;<br>        traversal(root);<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            ans[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traversal(root.left);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span> || prev.val != root.val) &#123;<br>            curCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curCount++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (curCount &gt; maxCount) &#123;<br>            maxCount = curCount;<br>            res.clear();<br>            res.add(root.val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curCount == maxCount) &#123;<br>            res.add(root.val);<br>        &#125;<br>        prev = root;<br>        traversal(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a> 为了寻找最近的公共祖先，当然是需要递归查看子树查询的结果，所以后序遍历的方式比较符合这个思路。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == p || root == q || root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a> 思路相似，但是利用了二叉搜索树的有序性质 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>        &#125; <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a> 直接按照其性质进行操作即可。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; val) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span>) &#123;<br>                    cur.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-literal">null</span>) &#123;<br>                    cur.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>*</strong> <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a> 这个方法不是很优雅，但是很有用。 遍历访问，根据二叉搜索树的特点，确定 key 在左/右子树中的哪一棵。 如果当前节点就是 key 所在的节点，则根据具体情况操作： 如果是叶子节点：那么正好把它去掉，返回 null 。 如果左右子树有一为空，那么返回不为空的那一棵树。 如果都不为空，那么这里处理： 主要思路是把它的左子树挂到右边，满足二叉搜索树的性质， 所以只需要一路在右子树上向左寻找，找到右子树的左叶子，把原节点的左子树挂在上面就好了。 最后返回右子树。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a> 处理思路： 如果当前节点的值已经比 low 小了 那么它的右子树和它本身都不需要了， 所以返回处理它的右子树的结果，另一种情况同理。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)   <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root.val &lt; low) <span class="hljs-keyword">return</span> trimBST(root.right, low, high);<br>        <span class="hljs-keyword">if</span> (root.val &gt; high) <span class="hljs-keyword">return</span> trimBST(root.left, low, high);<br>        root.left = trimBST(root.left, low, high);<br>        root.right = trimBST(root.right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a> 还是蛮简单的，这里生成一个平衡二叉树。 毕竟是有序数组，所以可以找到中间点，然后再继续递归把左右也生成即可。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = build(nums, l, mid - <span class="hljs-number">1</span>);<br>        root.right = build(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a> 首先看题干中的累加树是什么：</p><blockquote><p>累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p></blockquote><p>既然是大于等于，那么就是说先找大的，所以先访问右子树。 之后正常的中序遍历就好。 P.S. 好像维护一个 <code>int sum</code> 也没有优化内存消耗的样子（） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> TreeNode prev;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        build(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        build(root.right);<br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>            root.val += prev.val;<br>        &#125;<br>        prev = root;<br>        build(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>这里涉及到的内容基本都是二叉搜索树的内容。</p><p>基本上把握住<strong>中序遍历</strong>和<strong>有序序列</strong>的关系就可以知道该如何解决问题了。</p><p>需要把握的是具体遍历时的细节，比如访问时的处理，关键值的维护等等。</p><p>关于二叉树，主要是注意思路吧，这些还挺基础，都是数据结构课上学过的。</p><p>不过这里需要在意的是 <strong>删除</strong> 操作，要知道怎么处理节点及其左右子树。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part7 二叉树 中</title>
    <link href="/2022/03/01/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-2.%E4%B8%AD/"/>
    <url>/2022/03/01/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-2.%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>书接上回的基本操作，这里涉及到的内容依然是从<strong>遍历</strong>出发，在遍历的基础上增加一些别的操作 其中也涉及到了回溯等内容</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.right);<br>        <span class="hljs-comment">// 左叶子</span><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.left.left == <span class="hljs-literal">null</span> &amp;&amp; root.left.right == <span class="hljs-literal">null</span>) &#123;<br>            mid = root.left.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (mid + left + right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值</a> 其实还是层序遍历 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curnode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> ( !queue.isEmpty() ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> queue.peek();<br>                <span class="hljs-keyword">while</span> (curnode &gt; <span class="hljs-number">0</span>) &#123;<br>                    root = queue.poll();<br>                    curnode--;<br>                    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                        queue.add(root.left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>                        queue.add(root.right);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (queue.size() == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> left.val;<br>                &#125;<br>                curnode = queue.size();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a> 其实记录下标还是挺麻烦的…… <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inorder.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(inorder, postorder, <span class="hljs-number">0</span>, inorder.length-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr, <span class="hljs-type">int</span> posl, <span class="hljs-type">int</span> posr)</span> &#123;<br>        <span class="hljs-keyword">if</span> ((inr - inl) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[inl]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootval</span> <span class="hljs-operator">=</span> postorder[posr];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> rootidx;<br>        <span class="hljs-keyword">for</span> (rootidx = inl; rootidx &lt;= inr; rootidx++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[rootidx] == rootval) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rootidx != inl) &#123;<br>            root.left = build(inorder, postorder, inl, rootidx-<span class="hljs-number">1</span>, posl, posl + (rootidx-inl-<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rootidx != inr) &#123;<br>            root.right = build(inorder, postorder, rootidx+<span class="hljs-number">1</span>, inr, posl + (rootidx-inl), posr-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a> 普普通通构造二叉树，还是挺简单的 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (r &lt; l) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[l]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> l;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; max) &#123;<br>                max = nums[i];<br>                index = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(max);<br><br>        root.left = build(nums, l, index - <span class="hljs-number">1</span>);<br>        root.right = build(nums, index + <span class="hljs-number">1</span>, r);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> root1;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        root.val = root1.val + root2.val;<br>        root.left = mergeTrees(root1.left, root2.left);<br>        root.right = mergeTrees(root1.right, root2.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>这里需要注意的内容还是要能够分析</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part7 二叉树 上</title>
    <link href="/2022/02/27/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-1.%E4%B8%8A/"/>
    <url>/2022/02/27/Algorithm/Part7-%E4%BA%8C%E5%8F%89%E6%A0%91-1.%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>二叉树是老朋友了，倒不如说怎么这里的内容只有二叉树。 总之这里放一个模板 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>  TreeNode left;<br>  TreeNode right;<br>  TreeNode() &#123;&#125;<br>  TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>  TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>    <span class="hljs-built_in">this</span>.val = val;<br>    <span class="hljs-built_in">this</span>.left = left;<br>    <span class="hljs-built_in">this</span>.right = right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="例题">例题</h3><p>总之这里来集大成者的题： <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftdepth</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightdepth</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(leftdepth, rightdepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a> &gt; 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>最小深度需要判断叶子节点！所以判断依据要有哦。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">n叉树的最大深度</a> 因为写过层序遍历，所以套模板了。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(Node root)</span> &#123;<br>        Deque&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curnode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                res++;<br>                <span class="hljs-keyword">while</span> (curnode &gt; <span class="hljs-number">0</span>) &#123;<br>                    root = queue.poll();<br>                    curnode--;<br>                    <span class="hljs-keyword">for</span> (Node node : root.children) &#123;<br>                        queue.add(node);<br>                        next++;<br>                    &#125;<br>                &#125;<br>                curnode = next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a> 依然是可以套模板的…… <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curnode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                res += curnode;<br>                <span class="hljs-keyword">while</span> (curnode &gt; <span class="hljs-number">0</span>) &#123;<br>                    root = queue.poll();<br>                    curnode--;<br>                    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                        queue.add(root.left);<br>                        next++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>                        queue.add(root.right);<br>                        next++;<br>                    &#125;<br>                &#125;<br>                curnode = next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 甚至可以递归 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 通用递归解法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a> 其实只是一个判断操作啦，就是在计算深度的步骤里加一个判断是否平衡的内容。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> getHeight(root) == -<span class="hljs-number">1</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ldepth</span> <span class="hljs-operator">=</span> getHeight(root.left);<br>        <span class="hljs-keyword">if</span> (ldepth == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rdepth</span> <span class="hljs-operator">=</span> getHeight(root.right);<br>        <span class="hljs-keyword">if</span> (rdepth == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.abs(ldepth - rdepth) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : Math.max(ldepth, rdepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a> 其实还是遍历，只不过是用到了一个备份操作…… 相当于回溯吧，这里需要注意的是叶子节点的判断。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        traversal(root, ans, builder);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root, List&lt;String&gt; path, StringBuilder res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            res.append(Integer.toString(root.val));<br>            path.add(res.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        res.append(Integer.toString(root.val));<br>        res.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">backup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(res.toString());<br><br>        <span class="hljs-keyword">if</span> ( root.left != <span class="hljs-literal">null</span> ) &#123;<br>            traversal(root.left, path, res);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ( root.right != <span class="hljs-literal">null</span> ) &#123;<br>            traversal(root.right, path, backup);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="总结">总结</h3><p>涉及到的内容都是一些遍历的活，建议看当时上课的 ppt 比较好理解，虽然排版很简陋，但是内容相当泛用！ 现在再来看，确实还挺 <code>规格严格，功夫到家</code> 的，salute! 接下来是遍历的模板，直接放伪代码吧：</p><p>放一个先序的就行了，其余同理 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs (先序)">先根遍历二叉树<br>若二叉树非空则:<br>&#123;<br>    访问根节点;<br>    先根遍历左子树;<br>    先根遍历右子树;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>非递归的模板，同样以先序为例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs (先序)">Loop:<br>&#123;<br>    if (BT 非空) &#123; <br>        输出;<br>        进栈;<br>        左一步;<br>    &#125; else &#123;<br>        退栈；<br>        右一步;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>层序遍历： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Void <span class="hljs-title">LeverList</span><span class="hljs-params">(BTREE T)</span></span><br><span class="hljs-function"></span>&#123;<br>    QUEUE Q；<br>    BTREE p = T;<br>    <span class="hljs-built_in">MakeNull</span>(Q);<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-built_in">EnQueue</span>(p, Q);<br>        <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">Empty</span>(Q) ) &#123;<br>            p = <span class="hljs-built_in">DeQueue</span>(Q);<br>            <span class="hljs-built_in">visit</span>(p-&gt;data);<br>            <span class="hljs-keyword">if</span>(p-&gt;lchild)<br>                <span class="hljs-built_in">EnQueue</span>(p-&gt;lchild);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild)<br>                <span class="hljs-built_in">EnQueue</span>(p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part6 栈与队列</title>
    <link href="/2022/02/22/Algorithm/Part6-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/22/Algorithm/Part6-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>基本上是数据结构课程里提及的内容</p><h3 id="example">Example</h3><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a> 考察数据结构的使用理解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        dumpIn();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> stackOut.pop();        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        dumpIn();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpIn</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stackOut.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a> 很基本的栈思想 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> cur;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            cur = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-keyword">if</span> (ch != cur) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a> 这个是数据结构课上写过的，这里用 Java 写一写。 有现成的数据结构实现了确实是相当方便，这里需要注意的是减法和除法 eg: <code>6 9 /</code> 的结果是 <code>6 / 9</code> ，但实际上按照栈进出的顺序出来的是 <code>/ 9 6</code> ，所以需要调换位置，减法同理。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">switch</span> (s) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    stack.push(stack.pop() + stack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    stack.push(-stack.pop() + stack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    stack.push(stack.pop() * stack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp0</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp1</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(tmp1 / tmp0);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    stack.push(Integer.valueOf(s));<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a> 好直白的滑动窗口…… 其实也不是很直白啦，但是想清楚过程很重要，一个思考过程大概是这样的： &gt; 考虑极端情况: 假如 k = 5, 序列为 [4, 3, 2, 1, 5] 此时 deque 仅有一个元素5,<br/> 对于之后的序列:<br/> 如果下一个数字 &gt; 5 , 则新数字成为 deque 的元素;<br/> 如果下一个数字 &lt; 5 , 那太好了, 5还能用.<br/> 另一个情况：序列为 [5, 1, 2, 3, 4] 即最大数出现在前方的情况,<br/> 那么 deque 中必然有数跟在5后面, 没必要担心结果的情况.<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先装第一次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// push</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.add(nums[i]);<br>        &#125;<br>        ans[<span class="hljs-number">0</span>] = deque.peek();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// window move, pop.</span><br>            <span class="hljs-keyword">if</span> (nums[i-k] == deque.peek()) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-comment">// push.</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.addLast(nums[i]);<br><br>            ans[i - k + <span class="hljs-number">1</span>] = deque.peekFirst();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a> 巧了， Java 正好有一个数组实现的二叉堆 <code>PriorityQueue</code> ，正好可以用。 作为一个二叉堆，排序的时间复杂度为 <code>O(logk)</code> ，有 n 个元素需要排序，所以时间复杂度是 <code>O(nlogk)</code> 。 顺便补充一下别的知识： <code>Map</code> 的遍历方式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                        <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>        );<br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;key, val&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; val) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;key, val&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>感觉也都是容器方面的知识（？ 毕竟基础内容还是课程都学过啦。 结果容器方面的知识还蛮多的。 比如 <code>Deque</code> 其实常用来当 Stack 用，这里的参考资料是<a href="https://www.cnblogs.com/code-duck/p/13569388.html">为什么使用Deque而不使用Stack构造栈</a>和<a href="http://chengfeng96.com/blog/2018/01/20/Java%E4%B8%AD%E7%94%A8Deque%E6%8E%A5%E5%8F%A3%E4%BB%A3%E6%9B%BFStack%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%88%90%E6%A0%88%E5%8A%9F%E8%83%BD/">Java中用Deque接口代替Stack接口完成栈功能</a> 它既有 <em>LIFO</em> 的操作，又有 <em>FIFO</em> 的操作</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part5 双指针</title>
    <link href="/2022/02/21/Algorithm/Part5-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/21/Algorithm/Part5-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>双指针基本前面讲到啦。</p><p>这里就不再多说了吧。</p><p>就在这里强调一下 <a href="https://leetcode-cn.com/problems/3sum/">三数之和</a> 和 <a href="https://leetcode-cn.com/problems/4sum/">四数之和</a> 吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) right--;<br>                    left++; right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] + nums[j] &lt; (target - nums[left] - nums[right])) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[j] &gt; (target - nums[left] - nums[right])) &#123;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) right--;<br><br>                        left++; right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part4 字符串</title>
    <link href="/2022/02/21/Algorithm/Part4-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/02/21/Algorithm/Part4-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h3 id="example">Example</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/">反转字符串II</a></li><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">翻转字符串里的单词</a></li><li><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></li><li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a></li></ol><h4 id="字符串的基本用法">字符串的基本用法</h4><p><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a>从两头翻到中间就是反转字符串啦！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = s.length-<span class="hljs-number">1</span>; i &lt; s.length / <span class="hljs-number">2</span>; i++, j--) &#123;<br>            <span class="hljs-comment">// swap</span><br>            s[i] ^= s[j];<br>            s[j] ^= s[i];<br>            s[i] ^= s[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">反转字符串II</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch.length; i += <span class="hljs-number">2</span>*k) &#123;<br>            <span class="hljs-keyword">if</span> ((i + k) &lt;= ch.length) &#123;<br>                reverse(ch, i, i + k - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            reverse(ch, i, ch.length-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;<br>            ch[i] ^= ch[j];<br>            ch[j] ^= ch[i];<br>            ch[i] ^= ch[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a> 其实我想…… <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>)<br></code></pre></td></tr></table></figure> 但实际上 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                builder.append(<span class="hljs-string">&quot;  &quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (builder.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        s += builder;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br><br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ch[left] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                ch[right--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ch[right--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                ch[right] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ch[right] = ch[left];<br>            &#125;<br>            left--;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">翻转字符串里的单词</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> removeSpace(s);<br>        reverse(builder, <span class="hljs-number">0</span>, builder.length() - <span class="hljs-number">1</span>);<br>        reverseWord(builder);<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> StringBuilder <span class="hljs-title function_">removeSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span> (s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(start);<br>            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27; &#x27;</span> || builder.charAt(builder.length()-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                builder.append(ch);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder builder, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> builder.charAt(i);<br>            builder.setCharAt(i, builder.charAt(j));<br>            builder.setCharAt(j, tmp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWord</span><span class="hljs-params">(StringBuilder builder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> builder.length();<br>        <span class="hljs-keyword">while</span> (fast &lt; len) &#123;<br>            <span class="hljs-keyword">while</span> (fast &lt; len &amp;&amp; builder.charAt(fast) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                fast++;<br>            &#125;<br>            reverse(builder, slow, fast - <span class="hljs-number">1</span>);<br>            slow = fast + <span class="hljs-number">1</span>;<br>            fast = slow + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        reverse(ch, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);<br>        reverse(ch, n, ch.length-<span class="hljs-number">1</span>);<br>        reverse(ch, <span class="hljs-number">0</span>, ch.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;<br>            ch[i] ^= ch[j];<br>            ch[j] ^= ch[i];<br>            ch[i] ^= ch[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="kmp">KMP</h4><p>KMP是经典算法啦</p><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>        getNext(next, needle);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j+<span class="hljs-number">1</span>) != haystack.charAt(i)) &#123;<br>                j = next[j];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (haystack.charAt(i) == needle.charAt(j+<span class="hljs-number">1</span>)) &#123;<br>                j++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (j == needle.length() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> (i - needle.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next, String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 优化 next 数组，使得模式串不出现 p[j] == p[next[j]] 的情况。</span><br>            <span class="hljs-comment">// 注：两者相等的话按照 next 数组访问匹配依然失效。</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j+<span class="hljs-number">1</span>) != s.charAt(i)) &#123;<br>                j = next[j];<br>            &#125;<br>            <span class="hljs-comment">// 生成未优化的 next 数组</span><br>            <span class="hljs-keyword">if</span> (s.charAt(j+<span class="hljs-number">1</span>) == s.charAt(i))<br>                j++;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br><br>        getNext(next, s); <br>        <span class="hljs-keyword">if</span> (next[len-<span class="hljs-number">1</span>] != -<span class="hljs-number">1</span> &amp;&amp; len % (len - next[len-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next, String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 优化 next 数组，使得模式串不出现 p[j] == p[next[j]] 的情况。</span><br>            <span class="hljs-comment">// 注：两者相等的话按照 next 数组访问匹配依然失效。</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j+<span class="hljs-number">1</span>) != s.charAt(i)) &#123;<br>                j = next[j];<br>            &#125;<br>            <span class="hljs-comment">// 生成未优化的 next 数组</span><br>            <span class="hljs-keyword">if</span> (s.charAt(j+<span class="hljs-number">1</span>) == s.charAt(i))<br>                j++;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><blockquote><p>这里也给大家拓展一下字符串和数组有什么差别，</p><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。</p><p>在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。</p><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。 那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part3 哈希表</title>
    <link href="/2022/02/19/Algorithm/Part3-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/02/19/Algorithm/Part3-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>哈希表利用特殊规则直接访问元素，可以做到将查询的时间复杂度将为<code>O(1)</code>，但是对应的需要开辟空间来进行存储，所以空间复杂度变成了<code>O(1)</code>。</p><h3 id="example">Example</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/valid-anagram/">有效的字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></li><li><a href="https://leetcode-cn.com/problems/happy-number/">快乐数</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a> <!-- 5.  [四数相加II]()6.  []()7.  []()8.  []() --></li></ol><h4 id="简单应用">1. 简单应用</h4><p>对应<a href="https://leetcode-cn.com/problems/valid-anagram/">有效的字母异位词</a>，这里实际上是统计单词的字母出现次数，那么直接将其用哈希桶装起来就好了。 这里用了 Java 里的一个类似 foreach 的 for 循环操作。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] hashrec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            hashrec[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            hashrec[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : hashrec) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="容器使用">2. 容器使用</h4><p>对应<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-keyword">if</span> (nums1 == <span class="hljs-literal">null</span> || nums2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; resSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>            set1.add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (set1.contains(i)) &#123;<br>                resSet.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] resArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[resSet.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : resSet) &#123;<br>            resArr[index++] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对应<a href="https://leetcode-cn.com/problems/happy-number/">快乐数</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !record.contains(n)) &#123;<br>            record.add(n);<br>            n = getSum(n);<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            res += tmp * tmp;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对应<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(tmp)) &#123;<br>                res[<span class="hljs-number">1</span>] = i;<br>                res[<span class="hljs-number">0</span>] = map.get(tmp);<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="section">3.</h4><h3 id="总结">总结</h3><p>其实很多是 Java 的容器相关的知识呢。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part2 链表</title>
    <link href="/2022/02/19/Algorithm/Part2-%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/19/Algorithm/Part2-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><h4 id="链表定义">链表定义</h4><p>关于链表基本定义比如单、双链表和循环链表什么的都是在数据结构课上讲得相当详细了，这里不再赘述。 这里需要提一提的是当时没有详细解说的<strong>链表的储存形式</strong> - 与数组不同，链表并非连续存储，它是通过指针在内存中散乱着的地址一个一个指向实现的，分配机制取决于操作系统的内存管理。</p><p>这里展示一些手写链表的模式： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;            <span class="hljs-comment">// 节点储存的值</span><br>    ListNode *next;     <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x)， <span class="hljs-built_in">next</span>(null) &#123;&#125;    <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>Java版本： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过自己定义构造函数初始化节点： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></p><p>使用默认构造函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure></p><h4 id="链表基本操作">链表基本操作</h4><p>主要操作就是增、删节点：</p><p>增：增加节点的话，需要将上一个节点的 next 指向需要增加节点，增加节点的 next 指向上一个节点的 next 原指向的节点。 add-&gt;next = pre-&gt;next pre-&gt;next = add 大概类似这样操作。</p><p>删：删除节点需要将被删除节点的上一个节点的 next 指向删除节点的 next 。 pre-&gt;next = pre-&gt;next-&gt;next 大概如此。</p><h4 id="与数组比较">与数组比较</h4><table><thead><tr class="header"><th></th><th>插入/删除</th><th>查询</th><th>常见场景</th></tr></thead><tbody><tr class="odd"><td>数组</td><td>O(n)</td><td>O(1)</td><td>数据量固定，频繁查询，较少增删</td></tr><tr class="even"><td>链表</td><td>O(1)</td><td>O(n)</td><td>数据量不固定，频繁增删，较少查询</td></tr></tbody></table><h3 id="example">Example</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></li><li><a href="https://leetcode-cn.com/problems/design-linked-list/">设计链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">链表相交</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表II</a></li></ol><h4 id="虚拟头节点">1. 虚拟头节点</h4><p>对应第1题——移除链表元素 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> tmp;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="基本操作">2. 基本操作</h4><p>对应第2题——设计链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><br>    ListNode head;<br><br>    <span class="hljs-type">int</span> length;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        length = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= length) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cnt &lt;= index; cnt++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, val);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(length, val);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cnt &lt; index; cnt++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val, pre.next);<br>        pre.next = add;<br>        length++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cnt &lt; index; cnt++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = pre.next.next;<br>        length--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="section">3.</h4><p>对应第3题——反转链表 其实就是头插法啦。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        ListNode tmp;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            tmp = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 一个递归法： 图示如下 before: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null 最后递归返回的 next ：5 倒数第二步的结果： before: 4-&gt;5-&gt;null process: 5-&gt;4; 4-&gt;null after: 5-&gt;4-&gt;null 再上一步： before: 3-&gt;4-&gt;null 5-&gt;4-&gt;null process: 4-&gt;3; 3-&gt;null after: 5-&gt;4-&gt;3-&gt;null 思路就是如此啦。 递归的目的是一步一步地换位置，并且一路拿到最后想要的头节点。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;        <br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="section-1">4.</h4><p>对应第4题——两两交换链表中的节点 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmphead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head.next);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmppre</span> <span class="hljs-operator">=</span> tmphead;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmpone</span> <span class="hljs-operator">=</span> cur;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmptwo</span> <span class="hljs-operator">=</span> cur.next;<br><br>            tmpone.next = tmptwo.next;<br>            tmptwo.next = tmpone;<br>            tmppre.next = tmptwo;<br><br>            tmppre = tmpone;<br><br>            cur = tmpone.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmphead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="section-2">5.</h4><p>对应第5题——删除链表的倒数第N个节点 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyhead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummyhead;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummyhead;<br><br>        <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>            fast = fast.next;<br>            n--;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br><br>        slow.next = slow.next.next;<br><br>        <span class="hljs-keyword">return</span> dummyhead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="section-3">6.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">skipA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, skipB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123;<br>            lenA++;<br>            curA = curA.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">null</span>) &#123;<br>            lenB++;<br>            curB = curB.next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> lenA - lenB;<br>        <span class="hljs-keyword">if</span> (diff &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>                curA = curA.next;<br>                diff--;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            diff = diff * (-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>                curB = curB.next;<br>                diff--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA.next;<br>            curB = curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="section-4">7.</h4><p>虽然说是环形链表，其实这是数学题吧！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                fast = head;<br>                <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> fast;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="conclusion">Conclusion</h3><p>链表其实内容还是和数据结构里学的差不多，没有特别需要记录的… 所以实际是需要考虑到的操作是 基本操作 里的内容。 而且这里的虚拟头节点其实也是课程涉及到的内容呢。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part1 数组</title>
    <link href="/2022/02/18/Algorithm/Part1-%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/18/Algorithm/Part1-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3><p>这里是算法题学习记录的第一部分——数组。</p><p>数组可以说是基础中的基础吧，主要考验的是<strong>对代码的掌控能力</strong>，个人认为是把想法付诸实践的体现。</p><p>总共包含了5道题： 1. <a href="https://leetcode-cn.com/problems/binary-search/">二分查找</a> 2. <a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a> 3. <a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">有序数组的平方</a> 4. <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">长度最小的子数组</a> 5. <a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵II</a></p><h3 id="example">Example</h3><h4 id="直接的二分查找">1. 直接的二分查找</h4><p>二分查找很简单，就简单说下要点：</p><p>对应上面的题1，题干还请直接参见链接，下同。</p><p>首先这里提一下时间复杂度 - 直接求解法，也就是简单遍历的时间复杂度为： <code>O(n)</code> - 二分法的时间复杂度是： <code>O(log n)</code> ，具体过程可以回顾二叉树的思想，想象其作为一个二叉树的高度。</p><p>那么对于这一题，我们如何使用二分法呢？</p><p>一个比较容易理解而且不容易出错的方法是：设置一个中点，将它作为标志，与 target 进行比对，如果这个中点大于 target ，很显然， target 应该是在中点的前方，所以设置下一次寻找的尾端为 mid - 1 ，同理，对另一种情况可以设置下一次寻找的首端为 mid + 1。</p><p>这样一想感觉很合理，那么它究竟是不是没有问题的呢，我们设置的退出循环条件会不会出现失效的情况，从而让程序陷入死循环呢？</p><p>那么就想想是在什么情况下会导致死循环，即 <code>(front &lt;= back)</code> 永远成立，实际上并不会出现这样的情况，因为最极端的情况下，首尾端有一个与 mid 重合，那么在执行的过程中，必然会出现更新首/尾端，导致其为 mid + 1 或者是 mid - 1 的情况，就可以退出循环了！程序得救了！</p><p>解答： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; target || nums[nums.length - <span class="hljs-number">1</span>] &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">int</span> <span class="hljs-variable">back</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (front &lt;= back) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> front + ((back - front) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                front = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                back = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="双指针">2. 双指针</h4><p>第一次接触双指针还是数据结构课程上，老师讲的快慢表的应用。</p><p>当然这次的不太一样就是，直接看题目吧！</p><p>首先是第2题，要求移除元素，并且返回移除元素后的数组长度。</p><p>分析题目得知，实现的方法应该是检测这个特定元素，找到它后，让它被后面的元素覆盖，并且持续执行，但是如果仅仅是这么简单，效率相当低，所以使用双指针，一个标记我们最后需要的数组的实际操作位置，一般来说这个数组会小于原数组，所以这个指针一定是<strong>慢</strong>的，另一个寻找那个特定元素，它一定要访问整个数组长度，所以它应该是<strong>快</strong>的，这样我们就分析出了快慢指针的用法，那么接下来就是实现：</p><p>首先 fast 一路向前找，如果不是那个需要移除的元素 val ，那么大家都无视发生，而且这个元素也应该是 slow 的位置需要的元素，将其赋值到 slow 所在的位置上，这步操作完成后， slow 当然要指向下一个位置， 所以 slow++ ，fast 每次循环都要 ++ 就不提了。那么如果碰到了需要移除的元素呢？那么 slow 就不动，忽视它， fast 继续前进，这样就做到了移除的功能。</p><p>fast 一路前进，直到数组的尽头，最终 slow 的位置就是我们想要的数组的末端的<strong>后一位</strong>，所以它的值就是数组长度了。 这整个过程可以用循环实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; fast &lt; nums.length; fast++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第3题要求返回一个有序数组的平方，并且是排序的结果，因为这个数组包含了负数，而且负数的平方也有可能比正数的平方大，需要仔细处理！</p><p>因为是有序数组，我们可以想到，对于负数，平方大的其值必然小，所以会排在数组的前端，正数反之。</p><p>所以涉及两个指针，一个在头，一个在尾，那么这两个指针向中间移动的时候，指向的数的平方必然是越来越小的，所以就可以做到排序啦，我们要做的就是：设置这两个指针，每次比较这两个指针指向的数的平方的大小，谁大就要谁，并且向中间移动，控制循环的次数可以用原数组的长度，这样比较稳定保险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, back = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((nums[front] * nums[front]) &lt; (nums[back] * nums[back])) &#123;<br>                result[index] = nums[back] * nums[back];<br>                back--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[index] = nums[front] * nums[front];<br>                front++;<br>            &#125;<br>            index--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滑动窗口">3. 滑动窗口</h4><p>滑动窗口是第4题：长度最小的子数组</p><p>既然要找子数组，那么这个子数组当然是可以理解为被<strong>框</strong>起来的，这个框框就是滑动窗口，它只需要走一遍就可以找到这个子数组，效率还是不错的。</p><p>对于一个窗口来说，其首端如果后移动一位，就意味着其框住的内容少了一位，所以是内部总和减小的动作，反之，末端前进一位，内部总和增加，所以这两个操作可以做到及时更新子数组，并且判断和的大小。</p><p>因为目标是找到子数组和大于等于 target ，所以可以先放心的让 back 前进，并且更新 sum ，如果 (sum &gt;= target) ，即我们已经达到了目标，那么就要尝试着缩小这个子窗口，这个时候就要让 front 前进，并且更新 sum ，并且及时更新长度记录器，直到不满足条件为止，这样，等到 back 走到尽头，我们也把有可能的窗口都访问完成了，只需要返回最小值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, back = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; back &lt; nums.length; back++) &#123;<br>            sum += nums[back];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                result = Math.min(result, back - front + <span class="hljs-number">1</span>);<br>                sum -= nums[front];<br>                front++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>= Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模拟行为">4. 模拟行为</h4><p>这里为了尽量防止犯错，所以强行通过stride控制循环次数，很有用！ 螺旋数组相当经典了，主要做到的就是想清楚移动的方向和步数，以及循环的次数。</p><p>将这个过程明晰化：</p><p>需要循环的次数： 可以用对称的思想想象一下，如果遮住矩阵右半边，那么实际上需要向上运动的次数即为 n / 2 次，这就是需要的循环次数：<code>loop = n / 2</code></p><p>起点的设置和运动： 最开始的起点很自然的是 (0, 0) ， 那么接下来，每走过一圈，起点应该是往右下方运动，所以各自进行一次 -- 操作就好了。</p><p>进行一次运动的步数： 很好理解，最开始的步数应该是 n-1 ，因为每一次走了一圈嘛，所以下一次循环就少了一层，对于一个方向来说，就是需要少走两步，所以一次循环后更新步数 -2 。</p><p>如果是 n 为奇数的矩阵，那么还需要最后再填上最中间那一块的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> [][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start_X</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start_Y = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stride</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (loop &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start_X, j = start_Y;<br>            <span class="hljs-comment">// right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; stride; k++) &#123;<br>                res[i][j++] = count;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// down</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; stride; k++) &#123;<br>                res[i++][j] = count;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// left</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; stride; k++) &#123;<br>                res[i][j--] = count;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// up</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; stride; k++) &#123;<br>                res[i--][j] = count;<br>                count++;<br>            &#125;<br>            start_X++;<br>            start_Y++;<br>            stride -= <span class="hljs-number">2</span>;<br>            loop--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            res[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
